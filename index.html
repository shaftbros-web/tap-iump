<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>スマホ用シューティング</title>
<style>
  body {
    margin: 0;
    background: #000;
    overflow: hidden;
    touch-action: none;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #111;
  }
  #controls {
    position: fixed;
    bottom: 10px;
    left: 0;
    width: 100%;
    display: flex;
    justify-content: space-around;
    pointer-events: auto;
  }
  button {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: none;
    font-size: 20px;
    background: rgba(255,0,0,0.7);
    color: #fff;
    font-weight: bold;
  }
  #left, #right {
    background: rgba(0,0,255,0.6);
  }
  #up, #down {
    background: rgba(0,255,0,0.6);
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="controls">
  <button id="left">←</button>
  <button id="right">→</button>
  <button id="up">↑</button>
  <button id="down">↓</button>
  <button id="fire">FIRE</button>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// スマホ画面に合わせる
function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// --- プレイヤー ---
let player = {x: canvas.width/2, y: canvas.height-80, size: 20};
let bullets = [];

// 入力状態
let keys = {left:false,right:false,up:false,down:false,fire:false};

// ボタン操作
document.getElementById("left").ontouchstart = ()=>keys.left=true;
document.getElementById("left").ontouchend = ()=>keys.left=false;
document.getElementById("right").ontouchstart = ()=>keys.right=true;
document.getElementById("right").ontouchend = ()=>keys.right=false;
document.getElementById("up").ontouchstart = ()=>keys.up=true;
document.getElementById("up").ontouchend = ()=>keys.up=false;
document.getElementById("down").ontouchstart = ()=>keys.down=true;
document.getElementById("down").ontouchend = ()=>keys.down=false;
document.getElementById("fire").ontouchstart = ()=>{keys.fire=true;};
document.getElementById("fire").ontouchend = ()=>{keys.fire=false;};

// --- ゲームループ ---
function update(){
  if(keys.left) player.x -= 5;
  if(keys.right) player.x += 5;
  if(keys.up) player.y -= 5;
  if(keys.down) player.y += 5;

  if(keys.fire){
    bullets.push({x: player.x, y: player.y-20});
  }

  bullets.forEach(b=> b.y -= 8);
  bullets = bullets.filter(b=> b.y > 0);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="cyan";
  ctx.beginPath();
  ctx.arc(player.x,player.y,player.size,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle="yellow";
  bullets.forEach(b=>{
    ctx.fillRect(b.x-2,b.y-10,4,10);
  });
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>  }
  #left, #right {
    background: rgba(0,0,255,0.6);
  }
  #up, #down {
    background: rgba(0,255,0,0.6);
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="controls">
  <button id="left">←</button>
  <button id="right">→</button>
  <button id="up">↑</button>
  <button id="down">↓</button>
  <button id="fire">FIRE</button>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// スマホ画面に合わせる
function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// --- プレイヤー ---
let player = {x: canvas.width/2, y: canvas.height-80, size: 20};
let bullets = [];

// 入力状態
let keys = {left:false,right:false,up:false,down:false,fire:false};

// ボタン操作
document.getElementById("left").ontouchstart = ()=>keys.left=true;
document.getElementById("left").ontouchend = ()=>keys.left=false;
document.getElementById("right").ontouchstart = ()=>keys.right=true;
document.getElementById("right").ontouchend = ()=>keys.right=false;
document.getElementById("up").ontouchstart = ()=>keys.up=true;
document.getElementById("up").ontouchend = ()=>keys.up=false;
document.getElementById("down").ontouchstart = ()=>keys.down=true;
document.getElementById("down").ontouchend = ()=>keys.down=false;
document.getElementById("fire").ontouchstart = ()=>{keys.fire=true;};
document.getElementById("fire").ontouchend = ()=>{keys.fire=false;};

// --- ゲームループ ---
function update(){
  if(keys.left) player.x -= 5;
  if(keys.right) player.x += 5;
  if(keys.up) player.y -= 5;
  if(keys.down) player.y += 5;

  if(keys.fire){
    bullets.push({x: player.x, y: player.y-20});
  }

  bullets.forEach(b=> b.y -= 8);
  bullets = bullets.filter(b=> b.y > 0);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="cyan";
  ctx.beginPath();
  ctx.arc(player.x,player.y,player.size,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle="yellow";
  bullets.forEach(b=>{
    ctx.fillRect(b.x-2,b.y-10,4,10);
  });
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html><div id="controls">
  <div id="stick"><div id="stickKnob"></div></div>
  <div id="fire">FIRE</div>
</div>
<script>
'use strict';
(function(){
  // ===== 画面・DPR対応 =====
  const cv=document.getElementById('cv');
  const cx=cv.getContext('2d',{alpha:false});
  const HUD={ state:gid('state'), score:gid('score'), lives:gid('lives'), start:gid('btnStart'), pause:gid('btnPause'), reset:gid('btnReset') };
  const errBox=gid('err');
  const stick=document.getElementById('stick');
  const knob=document.getElementById('stickKnob');
  const fireBtn=document.getElementById('fire');
  function showErr(msg){ errBox.style.display='block'; errBox.textContent=String(msg); }
  if(!cx){ showErr('Canvas初期化に失敗'); }let vw=0,vh=0,dpr=1; function resize(){ dpr=Math.max(1, Math.min(3, window.devicePixelRatio||1)); vw=window.innerWidth; vh=window.innerHeight; cv.width=Math.floor(vwdpr); cv.height=Math.floor(vhdpr); cx.setTransform(dpr,0,0,dpr,0,0); } addEventListener('resize', resize); addEventListener('orientationchange', resize); resize();

// ===== 状態 ===== const STATE={title:'title',playing:'playing',paused:'paused',gameover:'gameover',win:'win'}; let state=STATE.title; const setState=s=>{state=s; HUD.state.textContent=s}; let score=0,lives=3;

// ===== ゲームオブジェクト ===== const player={x:vw0.18,y:vh0.5,r:14,speed:360,cd:0}; const bullets=[], enemies=[], bossBullets=[], lasers=[]; let enemyTimer=0, boss=null, finalBoss=null, finalBossTimer=null, midBossSpawned=false;

function reset(){ player.x=vw0.18; player.y=vh0.5; player.cd=0; bullets.length=enemies.length=bossBullets.length=lasers.length=0; enemyTimer=0; boss=null; finalBoss=null; finalBossTimer=null; midBossSpawned=false; score=0; lives=3; HUD.score.textContent=score; HUD.lives.textContent=lives; }

// ===== 入力（スティック＋ボタン＋キーボード） ===== let wantShoot=false, autoFire=false; const keys=new Set(); addEventListener('keydown',e=>{const k=(e.key||'').toLowerCase(); if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d',' '].includes(k)) e.preventDefault(); keys.add(k); if(k===' ') wantShoot=true;},{passive:false}); addEventListener('keyup',e=>{keys.delete((e.key||'').toLowerCase());},{passive:false});

// バーチャルスティック let joyActive=false, joyDX=0, joyDY=0, joyMax=1; // 正規化ベクトル function stickCenter(){ const r=stick.getBoundingClientRect(); return {cx:r.left+r.width/2, cy:r.top+r.height/2, rad:Math.min(r.width,r.height)/2}; } function updateKnob(px,py){ const {cx,cy,rad}=stickCenter(); const dx=px-cx, dy=py-cy; const dist=Math.hypot(dx,dy); const lim=rad0.9; const k = dist>lim ? lim/dist : 1; const nx=dxk, ny=dy*k; knob.style.transform=translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px)); joyDX = (dx===0&&dy===0)?0:(dx/lim); joyDY = (dx===0&&dy===0)?0:(dy/lim); const len=Math.min(1, Math.hypot(joyDX,joyDY)); if(len>0){ joyDX/=len; joyDY/=len; } } stick.addEventListener('pointerdown', ev=>{ joyActive=true; stick.setPointerCapture(ev.pointerId); updateKnob(ev.clientX,ev.clientY); ev.preventDefault(); },{passive:false}); stick.addEventListener('pointermove', ev=>{ if(!joyActive) return; updateKnob(ev.clientX,ev.clientY); }); function endStick(){ joyActive=false; joyDX=joyDY=0; knob.style.transform='translate(-50%,-50%)'; } stick.addEventListener('pointerup', endStick); stick.addEventListener('pointercancel', endStick); stick.addEventListener('pointerleave', endStick);

// 発射ボタン fireBtn.addEventListener('pointerdown', ev=>{ fireBtn.classList.add('pressed'); wantShoot=true; autoFire=true; ev.preventDefault(); },{passive:false}); function endFire(){ fireBtn.classList.remove('pressed'); autoFire=false; } fireBtn.addEventListener('pointerup', endFire); fireBtn.addEventListener('pointercancel', endFire); fireBtn.addEventListener('pointerleave', endFire);

// タブ非表示で一時停止 document.addEventListener('visibilitychange',()=>{ if(document.hidden && state===STATE.playing) setState(STATE.paused); });

// ===== ループ ===== let last=performance.now(); function loop(now){ const dt=Math.min(0.033, Math.max(0.001,(now-last)/1000)); last=now; if(state===STATE.playing) update(dt); draw(); requestAnimationFrame(loop); } requestAnimationFrame(loop);

// ===== 更新 ===== function update(dt){ // 移動（スティック優先 → キー） const dead=0.2; let up=false,down=false,left=false,right=false; if(joyActive){ up = (joyDY < -dead); down = (joyDY > dead); left = (joyDX < -dead); right = (joyDX > dead); } // キーの入力も合成 up = up || keys.has('arrowup') || keys.has('w'); down = down || keys.has('arrowdown') || keys.has('s'); left = left || keys.has('arrowleft') || keys.has('a'); right = right || keys.has('arrowright') || keys.has('d');

// 速度はスティックの強さでスケール
let speedScale = joyActive ? Math.min(1, Math.hypot(joyDX,joyDY)) : 1;
const v = player.speed * speedScale * dt;
if(up) player.y -= v; if(down) player.y += v; if(left) player.x -= v; if(right) player.x += v;
player.x=Math.max(player.r,Math.min(vw*0.8,player.x));
player.y=Math.max(player.r,Math.min(vh-player.r,player.y));

// ショット
player.cd-=dt; if((autoFire || wantShoot) && player.cd<=0){ bullets.push({x:player.x+player.r+2,y:player.y,vx:580,vy:0,r:5,life:1.3}); player.cd=autoFire?0.12:0.18; wantShoot=false; }
for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0 || b.x>vw+12) bullets.splice(i,1); }

// 雑魚
if(!boss && !finalBoss){
  enemyTimer-=dt; if(enemyTimer<=0){ enemyTimer=0.55; enemies.push({x:vw+20,y:40+Math.random()*(vh-80),r:14,vx:-220}); }
  for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.x+=e.vx*dt; if(e.x<-30){ enemies.splice(i,1); continue; }
    for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(circleHit(e.x,e.y,e.r, b.x,b.y,b.r)){ enemies.splice(i,1); bullets.splice(bi,1); score+=100; HUD.score.textContent=score; break; } }
    if(circleHit(e.x,e.y,e.r, player.x,player.y,player.r)){ enemies.splice(i,1); damage(); }
  }
  if(!midBossSpawned && score>=3000){ boss={x:vw+100,y:vh/2,r:44,hp:100,phase:1,vx:-70,cd:0}; midBossSpawned=true; }
}

// 中ボス
if(boss){
  boss.x+=boss.vx*dt; if(boss.x<vw*0.7) boss.vx=0; boss.cd-=dt;
  if(boss.phase===1){ if(boss.cd<=0){ boss.cd=0.42; bossBullets.push({x:boss.x,y:boss.y,vx:-220,vy:(Math.random()-0.5)*140,r:6}); } }
  else if(boss.phase===2){ if(boss.cd<=0){ boss.cd=0.1; const a=Math.random()*Math.PI*2; bossBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a)*200,vy:Math.sin(a)*200,r:4}); } if(Math.random()<0.02) lasers.push({x:boss.x-60,y:boss.y-110,w:220,h:220,time:0.5}); }
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(boss && circleHit(boss.x,boss.y,boss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); boss.hp-=1; if(boss.hp===50) boss.phase=2; if(boss.hp<=0){ score+=2000; HUD.score.textContent=score; boss=null; finalBossTimer=20; return; } } }
  if(boss && circleHit(boss.x,boss.y,boss.r, player.x,player.y,player.r)) damage();
}

// 最終ボス
if(finalBossTimer!==null){ finalBossTimer-=dt; if(finalBossTimer<=0){ finalBossTimer=null; finalBoss={x:vw+120,y:vh/2,r:52,hp:200,vx:-50,cd:0}; } }
if(finalBoss){
  finalBoss.x+=finalBoss.vx*dt; if(finalBoss.x<vw*0.65) finalBoss.vx=0; finalBoss.cd-=dt;
  if(finalBoss.cd<=0){ finalBoss.cd=0.16; const a=Math.random()*Math.PI*2; bossBullets.push({x:finalBoss.x,y:finalBoss.y,vx:Math.cos(a)*220,vy:Math.sin(a)*220,r:5}); }
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(finalBoss && circleHit(finalBoss.x,finalBoss.y,finalBoss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); finalBoss.hp-=10; if(finalBoss.hp<=0){ score+=5000; HUD.score.textContent=score; finalBoss=null; setState(STATE.win); break; } } }
}

// 敵弾／レーザー
for(let i=bossBullets.length-1;i>=0;i--){ const eb=bossBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>vw+40||eb.y<-40||eb.y>vh+40){ bossBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ bossBullets.splice(i,1); damage(); } }
for(let i=lasers.length-1;i>=0;i--){ const l=lasers[i]; l.time-=dt; if(l.time<=0){ lasers.splice(i,1); continue; } if(rectHit(l, player)){ lasers.splice(i,1); damage(); } }

}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); } }

// ===== 描画 ===== function draw(){ cx.fillStyle='#061123'; cx.fillRect(0,0,vw,vh); cx.globalAlpha=.35; for(let x=0;x<vw;x+=24){ for(let y=0;y<vh;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1; drawShip(player.x,player.y,player.r,'#7dd3fc'); bullets.forEach(b=>drawBullet(b)); enemies.forEach(e=>drawEnemy(e)); if(boss) drawBoss(boss,'#fde047'); if(finalBoss) drawBoss(finalBoss,'#f87171'); bossBullets.forEach(b=>drawEBullet(b)); lasers.forEach(l=>drawLaser(l)); if(state===STATE.title) banner('SF SHOOTER','▶ 開始 / 左：スティック 右：ショット'); if(state===STATE.paused) banner('PAUSED','もう一度ポーズで再開'); if(state===STATE.gameover) banner('GAME OVER','スコア: '+score); if(state===STATE.win) banner('YOU WIN','スコア: '+score); }

// ===== UIボタン ===== HUD.start.onclick=()=>{ if(state!==STATE.playing){ reset(); setState(STATE.playing); } }; HUD.pause.onclick=()=> setState(state===STATE.playing?STATE.paused:STATE.playing); HUD.reset.onclick=()=>{ reset(); setState(STATE.title); };

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function drawBoss(b,color){ cx.fillStyle=color; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); cx.fillStyle='#fff'; cx.fillText('HP:'+Math.max(0,Math.floor(b.hp||0)), b.x-24, b.y-b.r-10); } function drawLaser(l){ cx.fillStyle='rgba(255,0,0,0.45)'; cx.fillRect(l.x,l.y,l.w,l.h); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh0.3); cx.textAlign='center'; cx.font='700 48px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; } function rectHit(l,p){ return p.x>l.x && p.x<l.x+l.w && p.y>l.y && p.y<l.y+l.h; }

// ===== 簡易テスト ===== try{ console.assert(circleHit(0,0,10,9,0,1)===true,'circleHit TRUE'); console.assert(circleHit(0,0,10,25,0,1)===false,'circleHit FALSE'); }catch(e){ console.warn('tests failed', e); }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html><div id="controls">
  <div id="stick"><div id="stickKnob"></div></div>
  <div id="fire">FIRE</div>
</div>
<script>
'use strict';
(function(){
  // ===== 画面・DPR対応 =====
  const cv=document.getElementById('cv');
  const cx=cv.getContext('2d',{alpha:false});
  const HUD={ state:gid('state'), score:gid('score'), lives:gid('lives'), start:gid('btnStart'), pause:gid('btnPause'), reset:gid('btnReset') };
  const errBox=gid('err');
  const stick=document.getElementById('stick');
  const knob=document.getElementById('stickKnob');
  const fireBtn=document.getElementById('fire');
  function showErr(msg){ errBox.style.display='block'; errBox.textContent=String(msg); }
  if(!cx){ showErr('Canvas初期化に失敗'); }let vw=0,vh=0,dpr=1; function resize(){ dpr=Math.max(1, Math.min(3, window.devicePixelRatio||1)); vw=window.innerWidth; vh=window.innerHeight; cv.width=Math.floor(vwdpr); cv.height=Math.floor(vhdpr); cx.setTransform(dpr,0,0,dpr,0,0); } addEventListener('resize', resize); addEventListener('orientationchange', resize); resize();

// ===== 状態 ===== const STATE={title:'title',playing:'playing',paused:'paused',gameover:'gameover',win:'win'}; let state=STATE.title; const setState=s=>{state=s; HUD.state.textContent=s}; let score=0,lives=3;

// ===== ゲームオブジェクト ===== const player={x:vw0.18,y:vh0.5,r:14,speed:360,cd:0}; const bullets=[], enemies=[], bossBullets=[], lasers=[]; let enemyTimer=0, boss=null, finalBoss=null, finalBossTimer=null, midBossSpawned=false;

function reset(){ player.x=vw0.18; player.y=vh0.5; player.cd=0; bullets.length=enemies.length=bossBullets.length=lasers.length=0; enemyTimer=0; boss=null; finalBoss=null; finalBossTimer=null; midBossSpawned=false; score=0; lives=3; HUD.score.textContent=score; HUD.lives.textContent=lives; }

// ===== 入力（スティック＋ボタン＋キーボード） ===== let wantShoot=false, autoFire=false; const keys=new Set(); addEventListener('keydown',e=>{const k=(e.key||'').toLowerCase(); if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d',' '].includes(k)) e.preventDefault(); keys.add(k); if(k===' ') wantShoot=true;},{passive:false}); addEventListener('keyup',e=>{keys.delete((e.key||'').toLowerCase());},{passive:false});

// バーチャルスティック let joyActive=false, joyDX=0, joyDY=0, joyMax=1; // 正規化ベクトル function stickCenter(){ const r=stick.getBoundingClientRect(); return {cx:r.left+r.width/2, cy:r.top+r.height/2, rad:Math.min(r.width,r.height)/2}; } function updateKnob(px,py){ const {cx,cy,rad}=stickCenter(); const dx=px-cx, dy=py-cy; const dist=Math.hypot(dx,dy); const lim=rad0.9; const k = dist>lim ? lim/dist : 1; const nx=dxk, ny=dy*k; knob.style.transform=translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px)); joyDX = (dx===0&&dy===0)?0:(dx/lim); joyDY = (dx===0&&dy===0)?0:(dy/lim); const len=Math.min(1, Math.hypot(joyDX,joyDY)); if(len>0){ joyDX/=len; joyDY/=len; } } stick.addEventListener('pointerdown', ev=>{ joyActive=true; stick.setPointerCapture(ev.pointerId); updateKnob(ev.clientX,ev.clientY); ev.preventDefault(); },{passive:false}); stick.addEventListener('pointermove', ev=>{ if(!joyActive) return; updateKnob(ev.clientX,ev.clientY); }); function endStick(){ joyActive=false; joyDX=joyDY=0; knob.style.transform='translate(-50%,-50%)'; } stick.addEventListener('pointerup', endStick); stick.addEventListener('pointercancel', endStick); stick.addEventListener('pointerleave', endStick);

// 発射ボタン fireBtn.addEventListener('pointerdown', ev=>{ fireBtn.classList.add('pressed'); wantShoot=true; autoFire=true; ev.preventDefault(); },{passive:false}); function endFire(){ fireBtn.classList.remove('pressed'); autoFire=false; } fireBtn.addEventListener('pointerup', endFire); fireBtn.addEventListener('pointercancel', endFire); fireBtn.addEventListener('pointerleave', endFire);

// タブ非表示で一時停止 document.addEventListener('visibilitychange',()=>{ if(document.hidden && state===STATE.playing) setState(STATE.paused); });

// ===== ループ ===== let last=performance.now(); function loop(now){ const dt=Math.min(0.033, Math.max(0.001,(now-last)/1000)); last=now; if(state===STATE.playing) update(dt); draw(); requestAnimationFrame(loop); } requestAnimationFrame(loop);

// ===== 更新 ===== function update(dt){ // 移動（スティック優先 → キー） const dead=0.2; let up=false,down=false,left=false,right=false; if(joyActive){ up = (joyDY < -dead); down = (joyDY > dead); left = (joyDX < -dead); right = (joyDX > dead); } // キーの入力も合成 up = up || keys.has('arrowup') || keys.has('w'); down = down || keys.has('arrowdown') || keys.has('s'); left = left || keys.has('arrowleft') || keys.has('a'); right = right || keys.has('arrowright') || keys.has('d');

// 速度はスティックの強さでスケール
let speedScale = joyActive ? Math.min(1, Math.hypot(joyDX,joyDY)) : 1;
const v = player.speed * speedScale * dt;
if(up) player.y -= v; if(down) player.y += v; if(left) player.x -= v; if(right) player.x += v;
player.x=Math.max(player.r,Math.min(vw*0.8,player.x));
player.y=Math.max(player.r,Math.min(vh-player.r,player.y));

// ショット
player.cd-=dt; if((autoFire || wantShoot) && player.cd<=0){ bullets.push({x:player.x+player.r+2,y:player.y,vx:580,vy:0,r:5,life:1.3}); player.cd=autoFire?0.12:0.18; wantShoot=false; }
for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0 || b.x>vw+12) bullets.splice(i,1); }

// 雑魚
if(!boss && !finalBoss){
  enemyTimer-=dt; if(enemyTimer<=0){ enemyTimer=0.55; enemies.push({x:vw+20,y:40+Math.random()*(vh-80),r:14,vx:-220}); }
  for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.x+=e.vx*dt; if(e.x<-30){ enemies.splice(i,1); continue; }
    for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(circleHit(e.x,e.y,e.r, b.x,b.y,b.r)){ enemies.splice(i,1); bullets.splice(bi,1); score+=100; HUD.score.textContent=score; break; } }
    if(circleHit(e.x,e.y,e.r, player.x,player.y,player.r)){ enemies.splice(i,1); damage(); }
  }
  if(!midBossSpawned && score>=3000){ boss={x:vw+100,y:vh/2,r:44,hp:100,phase:1,vx:-70,cd:0}; midBossSpawned=true; }
}

// 中ボス
if(boss){
  boss.x+=boss.vx*dt; if(boss.x<vw*0.7) boss.vx=0; boss.cd-=dt;
  if(boss.phase===1){ if(boss.cd<=0){ boss.cd=0.42; bossBullets.push({x:boss.x,y:boss.y,vx:-220,vy:(Math.random()-0.5)*140,r:6}); } }
  else if(boss.phase===2){ if(boss.cd<=0){ boss.cd=0.1; const a=Math.random()*Math.PI*2; bossBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a)*200,vy:Math.sin(a)*200,r:4}); } if(Math.random()<0.02) lasers.push({x:boss.x-60,y:boss.y-110,w:220,h:220,time:0.5}); }
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(boss && circleHit(boss.x,boss.y,boss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); boss.hp-=1; if(boss.hp===50) boss.phase=2; if(boss.hp<=0){ score+=2000; HUD.score.textContent=score; boss=null; finalBossTimer=20; return; } } }
  if(boss && circleHit(boss.x,boss.y,boss.r, player.x,player.y,player.r)) damage();
}

// 最終ボス
if(finalBossTimer!==null){ finalBossTimer-=dt; if(finalBossTimer<=0){ finalBossTimer=null; finalBoss={x:vw+120,y:vh/2,r:52,hp:200,vx:-50,cd:0}; } }
if(finalBoss){
  finalBoss.x+=finalBoss.vx*dt; if(finalBoss.x<vw*0.65) finalBoss.vx=0; finalBoss.cd-=dt;
  if(finalBoss.cd<=0){ finalBoss.cd=0.16; const a=Math.random()*Math.PI*2; bossBullets.push({x:finalBoss.x,y:finalBoss.y,vx:Math.cos(a)*220,vy:Math.sin(a)*220,r:5}); }
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(finalBoss && circleHit(finalBoss.x,finalBoss.y,finalBoss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); finalBoss.hp-=10; if(finalBoss.hp<=0){ score+=5000; HUD.score.textContent=score; finalBoss=null; setState(STATE.win); break; } } }
}

// 敵弾／レーザー
for(let i=bossBullets.length-1;i>=0;i--){ const eb=bossBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>vw+40||eb.y<-40||eb.y>vh+40){ bossBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ bossBullets.splice(i,1); damage(); } }
for(let i=lasers.length-1;i>=0;i--){ const l=lasers[i]; l.time-=dt; if(l.time<=0){ lasers.splice(i,1); continue; } if(rectHit(l, player)){ lasers.splice(i,1); damage(); } }

}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); } }

// ===== 描画 ===== function draw(){ cx.fillStyle='#061123'; cx.fillRect(0,0,vw,vh); cx.globalAlpha=.35; for(let x=0;x<vw;x+=24){ for(let y=0;y<vh;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1; drawShip(player.x,player.y,player.r,'#7dd3fc'); bullets.forEach(b=>drawBullet(b)); enemies.forEach(e=>drawEnemy(e)); if(boss) drawBoss(boss,'#fde047'); if(finalBoss) drawBoss(finalBoss,'#f87171'); bossBullets.forEach(b=>drawEBullet(b)); lasers.forEach(l=>drawLaser(l)); if(state===STATE.title) banner('SF SHOOTER','▶ 開始 / 左：スティック 右：ショット'); if(state===STATE.paused) banner('PAUSED','もう一度ポーズで再開'); if(state===STATE.gameover) banner('GAME OVER','スコア: '+score); if(state===STATE.win) banner('YOU WIN','スコア: '+score); }

// ===== UIボタン ===== HUD.start.onclick=()=>{ if(state!==STATE.playing){ reset(); setState(STATE.playing); } }; HUD.pause.onclick=()=> setState(state===STATE.playing?STATE.paused:STATE.playing); HUD.reset.onclick=()=>{ reset(); setState(STATE.title); };

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function drawBoss(b,color){ cx.fillStyle=color; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); cx.fillStyle='#fff'; cx.fillText('HP:'+Math.max(0,Math.floor(b.hp||0)), b.x-24, b.y-b.r-10); } function drawLaser(l){ cx.fillStyle='rgba(255,0,0,0.45)'; cx.fillRect(l.x,l.y,l.w,l.h); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh0.3); cx.textAlign='center'; cx.font='700 48px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; } function rectHit(l,p){ return p.x>l.x && p.x<l.x+l.w && p.y>l.y && p.y<l.y+l.h; }

// ===== 簡易テスト ===== try{ console.assert(circleHit(0,0,10,9,0,1)===true,'circleHit TRUE'); console.assert(circleHit(0,0,10,25,0,1)===false,'circleHit FALSE'); }catch(e){ console.warn('tests failed', e); }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html><div id="controls">
  <div id="stick"><div id="stickKnob"></div></div>
  <div id="fire">FIRE</div>
</div>
<script>
'use strict';
(function(){
  // ===== 画面・DPR対応 =====
  const cv=document.getElementById('cv');
  const cx=cv.getContext('2d',{alpha:false});
  const HUD={ state:gid('state'), score:gid('score'), lives:gid('lives'), start:gid('btnStart'), pause:gid('btnPause'), reset:gid('btnReset') };
  const errBox=gid('err');
  const stick=document.getElementById('stick');
  const knob=document.getElementById('stickKnob');
  const fireBtn=document.getElementById('fire');
  function showErr(msg){ errBox.style.display='block'; errBox.textContent=String(msg); }
  if(!cx){ showErr('Canvas初期化に失敗'); }let vw=0,vh=0,dpr=1; function resize(){ dpr=Math.max(1, Math.min(3, window.devicePixelRatio||1)); vw=window.innerWidth; vh=window.innerHeight; cv.width=Math.floor(vwdpr); cv.height=Math.floor(vhdpr); cx.setTransform(dpr,0,0,dpr,0,0); } addEventListener('resize', resize); addEventListener('orientationchange', resize); resize();

// ===== 状態 ===== const STATE={title:'title',playing:'playing',paused:'paused',gameover:'gameover',win:'win'}; let state=STATE.title; const setState=s=>{state=s; HUD.state.textContent=s}; let score=0,lives=3;

// ===== ゲームオブジェクト ===== const player={x:vw0.18,y:vh0.5,r:14,speed:360,cd:0}; const bullets=[], enemies=[], bossBullets=[], lasers=[]; let enemyTimer=0, boss=null, finalBoss=null, finalBossTimer=null, midBossSpawned=false;

function reset(){ player.x=vw0.18; player.y=vh0.5; player.cd=0; bullets.length=enemies.length=bossBullets.length=lasers.length=0; enemyTimer=0; boss=null; finalBoss=null; finalBossTimer=null; midBossSpawned=false; score=0; lives=3; HUD.score.textContent=score; HUD.lives.textContent=lives; }

// ===== 入力（スティック＋ボタン＋キーボード） ===== let wantShoot=false, autoFire=false; const keys=new Set(); addEventListener('keydown',e=>{const k=(e.key||'').toLowerCase(); if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d',' '].includes(k)) e.preventDefault(); keys.add(k); if(k===' ') wantShoot=true;},{passive:false}); addEventListener('keyup',e=>{keys.delete((e.key||'').toLowerCase());},{passive:false});

// バーチャルスティック let joyActive=false, joyDX=0, joyDY=0, joyMax=1; // 正規化ベクトル function stickCenter(){ const r=stick.getBoundingClientRect(); return {cx:r.left+r.width/2, cy:r.top+r.height/2, rad:Math.min(r.width,r.height)/2}; } function updateKnob(px,py){ const {cx,cy,rad}=stickCenter(); const dx=px-cx, dy=py-cy; const dist=Math.hypot(dx,dy); const lim=rad0.9; const k = dist>lim ? lim/dist : 1; const nx=dxk, ny=dy*k; knob.style.transform=translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px)); joyDX = (dx===0&&dy===0)?0:(dx/lim); joyDY = (dx===0&&dy===0)?0:(dy/lim); const len=Math.min(1, Math.hypot(joyDX,joyDY)); if(len>0){ joyDX/=len; joyDY/=len; } } stick.addEventListener('pointerdown', ev=>{ joyActive=true; stick.setPointerCapture(ev.pointerId); updateKnob(ev.clientX,ev.clientY); ev.preventDefault(); },{passive:false}); stick.addEventListener('pointermove', ev=>{ if(!joyActive) return; updateKnob(ev.clientX,ev.clientY); }); function endStick(){ joyActive=false; joyDX=joyDY=0; knob.style.transform='translate(-50%,-50%)'; } stick.addEventListener('pointerup', endStick); stick.addEventListener('pointercancel', endStick); stick.addEventListener('pointerleave', endStick);

// 発射ボタン fireBtn.addEventListener('pointerdown', ev=>{ fireBtn.classList.add('pressed'); wantShoot=true; autoFire=true; ev.preventDefault(); },{passive:false}); function endFire(){ fireBtn.classList.remove('pressed'); autoFire=false; } fireBtn.addEventListener('pointerup', endFire); fireBtn.addEventListener('pointercancel', endFire); fireBtn.addEventListener('pointerleave', endFire);

// タブ非表示で一時停止 document.addEventListener('visibilitychange',()=>{ if(document.hidden && state===STATE.playing) setState(STATE.paused); });

// ===== ループ ===== let last=performance.now(); function loop(now){ const dt=Math.min(0.033, Math.max(0.001,(now-last)/1000)); last=now; if(state===STATE.playing) update(dt); draw(); requestAnimationFrame(loop); } requestAnimationFrame(loop);

// ===== 更新 ===== function update(dt){ // 移動（スティック優先 → キー） const dead=0.2; let up=false,down=false,left=false,right=false; if(joyActive){ up = (joyDY < -dead); down = (joyDY > dead); left = (joyDX < -dead); right = (joyDX > dead); } // キーの入力も合成 up = up || keys.has('arrowup') || keys.has('w'); down = down || keys.has('arrowdown') || keys.has('s'); left = left || keys.has('arrowleft') || keys.has('a'); right = right || keys.has('arrowright') || keys.has('d');

// 速度はスティックの強さでスケール
let speedScale = joyActive ? Math.min(1, Math.hypot(joyDX,joyDY)) : 1;
const v = player.speed * speedScale * dt;
if(up) player.y -= v; if(down) player.y += v; if(left) player.x -= v; if(right) player.x += v;
player.x=Math.max(player.r,Math.min(vw*0.8,player.x));
player.y=Math.max(player.r,Math.min(vh-player.r,player.y));

// ショット
player.cd-=dt; if((autoFire || wantShoot) && player.cd<=0){ bullets.push({x:player.x+player.r+2,y:player.y,vx:580,vy:0,r:5,life:1.3}); player.cd=autoFire?0.12:0.18; wantShoot=false; }
for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0 || b.x>vw+12) bullets.splice(i,1); }

// 雑魚
if(!boss && !finalBoss){
  enemyTimer-=dt; if(enemyTimer<=0){ enemyTimer=0.55; enemies.push({x:vw+20,y:40+Math.random()*(vh-80),r:14,vx:-220}); }
  for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.x+=e.vx*dt; if(e.x<-30){ enemies.splice(i,1); continue; }
    for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(circleHit(e.x,e.y,e.r, b.x,b.y,b.r)){ enemies.splice(i,1); bullets.splice(bi,1); score+=100; HUD.score.textContent=score; break; } }
    if(circleHit(e.x,e.y,e.r, player.x,player.y,player.r)){ enemies.splice(i,1); damage(); }
  }
  if(!midBossSpawned && score>=3000){ boss={x:vw+100,y:vh/2,r:44,hp:100,phase:1,vx:-70,cd:0}; midBossSpawned=true; }
}

// 中ボス
if(boss){
  boss.x+=boss.vx*dt; if(boss.x<vw*0.7) boss.vx=0; boss.cd-=dt;
  if(boss.phase===1){ if(boss.cd<=0){ boss.cd=0.42; bossBullets.push({x:boss.x,y:boss.y,vx:-220,vy:(Math.random()-0.5)*140,r:6}); } }
  else if(boss.phase===2){ if(boss.cd<=0){ boss.cd=0.1; const a=Math.random()*Math.PI*2; bossBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a)*200,vy:Math.sin(a)*200,r:4}); } if(Math.random()<0.02) lasers.push({x:boss.x-60,y:boss.y-110,w:220,h:220,time:0.5}); }
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(boss && circleHit(boss.x,boss.y,boss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); boss.hp-=1; if(boss.hp===50) boss.phase=2; if(boss.hp<=0){ score+=2000; HUD.score.textContent=score; boss=null; finalBossTimer=20; return; } } }
  if(boss && circleHit(boss.x,boss.y,boss.r, player.x,player.y,player.r)) damage();
}

// 最終ボス
if(finalBossTimer!==null){ finalBossTimer-=dt; if(finalBossTimer<=0){ finalBossTimer=null; finalBoss={x:vw+120,y:vh/2,r:52,hp:200,vx:-50,cd:0}; } }
if(finalBoss){
  finalBoss.x+=finalBoss.vx*dt; if(finalBoss.x<vw*0.65) finalBoss.vx=0; finalBoss.cd-=dt;
  if(finalBoss.cd<=0){ finalBoss.cd=0.16; const a=Math.random()*Math.PI*2; bossBullets.push({x:finalBoss.x,y:finalBoss.y,vx:Math.cos(a)*220,vy:Math.sin(a)*220,r:5}); }
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(finalBoss && circleHit(finalBoss.x,finalBoss.y,finalBoss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); finalBoss.hp-=10; if(finalBoss.hp<=0){ score+=5000; HUD.score.textContent=score; finalBoss=null; setState(STATE.win); break; } } }
}

// 敵弾／レーザー
for(let i=bossBullets.length-1;i>=0;i--){ const eb=bossBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>vw+40||eb.y<-40||eb.y>vh+40){ bossBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ bossBullets.splice(i,1); damage(); } }
for(let i=lasers.length-1;i>=0;i--){ const l=lasers[i]; l.time-=dt; if(l.time<=0){ lasers.splice(i,1); continue; } if(rectHit(l, player)){ lasers.splice(i,1); damage(); } }

}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); } }

// ===== 描画 ===== function draw(){ cx.fillStyle='#061123'; cx.fillRect(0,0,vw,vh); cx.globalAlpha=.35; for(let x=0;x<vw;x+=24){ for(let y=0;y<vh;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1; drawShip(player.x,player.y,player.r,'#7dd3fc'); bullets.forEach(b=>drawBullet(b)); enemies.forEach(e=>drawEnemy(e)); if(boss) drawBoss(boss,'#fde047'); if(finalBoss) drawBoss(finalBoss,'#f87171'); bossBullets.forEach(b=>drawEBullet(b)); lasers.forEach(l=>drawLaser(l)); if(state===STATE.title) banner('SF SHOOTER','▶ 開始 / 左：スティック 右：ショット'); if(state===STATE.paused) banner('PAUSED','もう一度ポーズで再開'); if(state===STATE.gameover) banner('GAME OVER','スコア: '+score); if(state===STATE.win) banner('YOU WIN','スコア: '+score); }

// ===== UIボタン ===== HUD.start.onclick=()=>{ if(state!==STATE.playing){ reset(); setState(STATE.playing); } }; HUD.pause.onclick=()=> setState(state===STATE.playing?STATE.paused:STATE.playing); HUD.reset.onclick=()=>{ reset(); setState(STATE.title); };

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function drawBoss(b,color){ cx.fillStyle=color; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); cx.fillStyle='#fff'; cx.fillText('HP:'+Math.max(0,Math.floor(b.hp||0)), b.x-24, b.y-b.r-10); } function drawLaser(l){ cx.fillStyle='rgba(255,0,0,0.45)'; cx.fillRect(l.x,l.y,l.w,l.h); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh0.3); cx.textAlign='center'; cx.font='700 48px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; } function rectHit(l,p){ return p.x>l.x && p.x<l.x+l.w && p.y>l.y && p.y<l.y+l.h; }

// ===== 簡易テスト ===== try{ console.assert(circleHit(0,0,10,9,0,1)===true,'circleHit TRUE'); console.assert(circleHit(0,0,10,25,0,1)===false,'circleHit FALSE'); }catch(e){ console.warn('tests failed', e); }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html>ick=()=>{ reset(); setState(STATE.title); };

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function drawBoss(b,color){ cx.fillStyle=color; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); cx.fillStyle='#fff'; cx.fillText('HP:'+Math.max(0,Math.floor(b.hp||0)), b.x-24, b.y-b.r-10); } function drawLaser(l){ cx.fillStyle='rgba(255,0,0,0.45)'; cx.fillRect(l.x,l.y,l.w,l.h); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh0.3); cx.textAlign='center'; cx.font='700 48px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; } function rectHit(l,p){ return p.x>l.x && p.x<l.x+l.w && p.y>l.y && p.y<l.y+l.h; }

// ===== 簡易テスト ===== try{ console.assert(circleHit(0,0,10,9,0,1)===true,'circleHit TRUE'); console.assert(circleHit(0,0,10,25,0,1)===false,'circleHit FALSE'); }catch(e){ console.warn('tests failed', e); }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html>
const HUD={ state:gid('state'), score:gid('score'), lives:gid('lives'), start:gid('btnStart'), pause:gid('btnPause'), reset:gid('btnReset') };
for(const [k,v] of Object.entries(HUD)) if(!v){ showErr('HUD要素が見つかりません: '+k); return; }

const STATE={title:'title',playing:'playing',paused:'paused',gameover:'gameover',win:'win'}; let state=STATE.title; const setState=s=>{state=s; HUD.state.textContent=s};

// 入力
const keys=new Set(); let wantShoot=false; let midBossSpawned=false;
addEventListener('keydown',e=>{const c=e.code, k=(e.key||'').toLowerCase(); const g=['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space','KeyW','KeyA','KeyS','KeyD','KeyP'].includes(c)||['arrowup','arrowdown','arrowleft','arrowright',' ','w','a','s','d','p'].includes(k); if(g) e.preventDefault(); keys.add((k||c).toLowerCase()); if(c==='Space'||k===' ') wantShoot=true; if(c==='KeyP'||k==='p') togglePause();},{passive:false});
addEventListener('keyup',e=>{const c=e.code, k=(e.key||'').toLowerCase(); keys.delete((k||c).toLowerCase());},{passive:false});

HUD.start.onclick=()=>{ if(state!==STATE.playing){ reset(); setState(STATE.playing); cv.focus(); } };
HUD.pause.onclick=()=> togglePause();
HUD.reset.onclick=()=>{ reset(); setState(STATE.title); };
function togglePause(){ setState(state===STATE.playing?STATE.paused:STATE.playing); }

// 世界
const player={x:cv.width*0.18,y:cv.height*0.5,r:14,speed:300,cd:0};
const bullets=[], enemies=[], bossBullets=[], lasers=[];
let enemyTimer=0, boss=null, finalBoss=null, finalBossTimer=null, score=0, lives=3;

function reset(){
  player.x=cv.width*0.18; player.y=cv.height*0.5; player.cd=0;
  bullets.length=0; enemies.length=0; bossBullets.length=0; lasers.length=0;
  enemyTimer=0; boss=null; finalBoss=null; finalBossTimer=null; midBossSpawned=false;
  score=0; lives=3; HUD.score.textContent=score; HUD.lives.textContent=lives;
}

// ループ
let last=performance.now();
function loop(now){ const dt=Math.min(0.033,Math.max(0.001,(now-last)/1000)); last=now; if(state===STATE.playing) update(dt); draw(); requestAnimationFrame(loop);} requestAnimationFrame(loop);

function update(dt){
  // 入力
  const up=keys.has('arrowup')||keys.has('keyw'); const down=keys.has('arrowdown')||keys.has('keys'); const left=keys.has('arrowleft')||keys.has('keya'); const right=keys.has('arrowright')||keys.has('keyd');
  if(up) player.y-=player.speed*dt; if(down) player.y+=player.speed*dt; if(left) player.x-=player.speed*dt; if(right) player.x+=player.speed*dt;
  player.x=Math.max(player.r,Math.min(cv.width*0.8,player.x)); player.y=Math.max(player.r,Math.min(cv.height-player.r,player.y));

  // 自機弾
  player.cd-=dt; if(wantShoot && player.cd<=0){ bullets.push({x:player.x+player.r+2,y:player.y,vx:580,vy:0,r:4,life:1.3}); player.cd=0.12; wantShoot=false; }
  for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0||b.x>cv.width+12) bullets.splice(i,1); }

  // 雑魚（ボス不在時のみ）
  if(!boss && !finalBoss){
    enemyTimer-=dt; if(enemyTimer<=0){ enemyTimer=0.5; enemies.push({x:cv.width+20,y:40+Math.random()*(cv.height-80),r:12,vx:-200}); }
    for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.x+=e.vx*dt; if(e.x<-30){ enemies.splice(i,1); continue; }
      // 弾 vs 雑魚
      for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(circleHit(e.x,e.y,e.r, b.x,b.y,b.r)){ enemies.splice(i,1); bullets.splice(bi,1); score+=100; HUD.score.textContent=score; break; } }
      // 雑魚 vs 自機
      if(circleHit(e.x,e.y,e.r, player.x,player.y,player.r)){ enemies.splice(i,1); damage(); }
    }
    // 中ボス出現（1回のみ）
    if(!midBossSpawned && score>=3000){ boss={x:cv.width+100,y:cv.height/2,r:40,hp:100,phase:1,vx:-60,cd:0}; midBossSpawned=true; }
  }

  // 中ボス
  if(boss){
    boss.x+=boss.vx*dt; if(boss.x<cv.width*0.7) boss.vx=0; boss.cd-=dt;
    if(boss.phase===1){ if(boss.cd<=0){ boss.cd=0.4; bossBullets.push({x:boss.x,y:boss.y,vx:-200,vy:(Math.random()-0.5)*120,r:6}); } }
    else if(boss.phase===2){ if(boss.cd<=0){ boss.cd=0.1; const a=Math.random()*Math.PI*2; bossBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a)*180,vy:Math.sin(a)*180,r:4}); } if(Math.random()<0.02) lasers.push({x:boss.x-50,y:boss.y-100,w:200,h:200,time:0.5}); }

    // 自機弾 vs 中ボス（nullガード＋早期スキップ入り）
    for(let bi=bullets.length-1; bi>=0; bi--){ const b=bullets[bi]; if(boss && circleHit(boss.x,boss.y,boss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); boss.hp-=1; if(boss.hp===50) boss.phase=2; if(boss.hp<=0){ score+=2000; HUD.score.textContent=score; boss=null; finalBossTimer=20; return; } } }

    // 体当たり（bossが存在する時のみ）
    if(boss && circleHit(boss.x,boss.y,boss.r, player.x,player.y,player.r)) damage();
  }

  // 最終ボス出現タイマー
  if(finalBossTimer!==null){ finalBossTimer-=dt; if(finalBossTimer<=0){ finalBossTimer=null; finalBoss={x:cv.width+120,y:cv.height/2,r:50,hp:200,vx:-40,cd:0}; } }

  // 最終ボス
  if(finalBoss){
    finalBoss.x+=finalBoss.vx*dt; if(finalBoss.x<cv.width*0.65) finalBoss.vx=0; finalBoss.cd-=dt;
    if(finalBoss.cd<=0){ finalBoss.cd=0.15; const a=Math.random()*Math.PI*2; bossBullets.push({x:finalBoss.x,y:finalBoss.y,vx:Math.cos(a)*200,vy:Math.sin(a)*200,r:5}); }
    // 自機弾 vs 最終ボス（防御）
    for(let bi=bullets.length-1; bi>=0; bi--){ const b=bullets[bi]; if(finalBoss && circleHit(finalBoss.x,finalBoss.y,finalBoss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); finalBoss.hp-=10; if(finalBoss.hp<=0){ score+=5000; HUD.score.textContent=score; finalBoss=null; setState(STATE.win); break; } } }
  }

  // 敵弾
  for(let i=bossBullets.length-1;i>=0;i--){ const eb=bossBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>cv.width+40||eb.y<-40||eb.y>cv.height+40){ bossBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ bossBullets.splice(i,1); damage(); } }

  // レーザー
  for(let i=lasers.length-1;i>=0;i--){ const l=lasers[i]; l.time-=dt; if(l.time<=0){ lasers.splice(i,1); continue; } if(rectHit(l, player)){ lasers.splice(i,1); damage(); } }
}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); } }

function draw(){
  cx.clearRect(0,0,cv.width,cv.height);
  // 背景
  cx.globalAlpha=.35; for(let x=0;x<cv.width;x+=24){ for(let y=0;y<cv.height;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1;
  // 自機
  drawShip(player.x,player.y,player.r,'#7dd3fc');
  // 弾
  bullets.forEach(b=>drawBullet(b));
  // 雑魚
  enemies.forEach(e=>drawEnemy(e));
  // ボス
  if(boss) drawBoss(boss,'#fde047');
  if(finalBoss) drawBoss(finalBoss,'#f87171');
  // 敵弾
  bossBullets.forEach(b=>drawEBullet(b));
  // レーザー
  lasers.forEach(l=>drawLaser(l));

  if(state===STATE.title) banner('SF SHOOTER','▶ スタートで開始 / 矢印・WASD・Space');
  if(state===STATE.paused) banner('PAUSED','P で再開');
  if(state===STATE.gameover) banner('GAME OVER','スコア: '+score);
  if(state===STATE.win) banner('YOU WIN','スコア: '+score);
}

// 描画ヘルパ
function drawShip(x,y,r,color){ cx.shadowColor=color; cx.shadowBlur=18; cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r*0.8,y-r*0.9); cx.lineTo(x-r*0.6,y+r*0.9); cx.closePath(); cx.fill(); cx.shadowBlur=0; }
function drawBullet(b){ cx.shadowColor='#67e8f9'; cx.shadowBlur=12; cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI*2); cx.fill(); cx.shadowBlur=0; }
function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI*2); cx.fill(); }
function drawEnemy(e){ cx.shadowColor='#a78bfa'; cx.shadowBlur=16; cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI*2); cx.fill(); cx.shadowBlur=0; }
function drawBoss(b,color){ cx.shadowColor=color; cx.shadowBlur=24; cx.fillStyle=color; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI*2); cx.fill(); cx.shadowBlur=0; cx.fillStyle='#fff'; cx.fillText('HP:'+Math.max(0,Math.floor(b.hp||0)), b.x-24, b.y-b.r-10); }
function drawLaser(l){ cx.fillStyle='rgba(255,0,0,0.45)'; cx.fillRect(l.x,l.y,l.w,l.h); }
function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, cv.height*0.35, cv.width, cv.height*0.3); cx.textAlign='center'; cx.font='700 64px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, cv.width/2, cv.height/2); cx.font = '14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, cv.width/2, cv.height/2+28); }

// 判定
function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dx*dx+dy*dy<=rr*rr; }
function rectHit(l,p){ return p.x>l.x && p.x<l.x+l.w && p.y>l.y && p.y<l.y+l.h; }

// 簡易テスト
try{
  console.assert(circleHit(0,0,10, 9,0,1)===true, 'circleHit TRUE');
  console.assert(circleHit(0,0,10, 25,0,1)===false, 'circleHit FALSE');
  console.assert(rectHit({x:0,y:0,w:10,h:10},{x:5,y:5})===true, 'rectHit TRUE');
  console.assert(rectHit({x:0,y:0,w:10,h:10},{x:20,y:20})===false, 'rectHit FALSE');
}catch(e){ console.warn('self tests failed', e); }

function gid(id){ return document.getElementById(id); }

} })(); </script>

</body>
</html>0,0,0.45)'; cx.fillRect(0, cv.height*0.35, cv.width, cv.height*0.3); cx.textAlign='center'; cx.font='700 64px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, cv.width/2, cv.height/2); cx.font = '14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, cv.width/2, cv.height/2+28); }

// 判定
function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dx*dx+dy*dy<=rr*rr; }
function rectHit(l,p){ return p.x>l.x && p.x<l.x+l.w && p.y>l.y && p.y<l.y+l.h; }

// 簡易テスト
try{
  console.assert(circleHit(0,0,10, 9,0,1)===true, 'circleHit TRUE');
  console.assert(circleHit(0,0,10, 25,0,1)===false, 'circleHit FALSE');
  console.assert(rectHit({x:0,y:0,w:10,h:10},{x:5,y:5})===true, 'rectHit TRUE');
  console.assert(rectHit({x:0,y:0,w:10,h:10},{x:20,y:20})===false, 'rectHit FALSE');
}catch(e){ console.warn('self tests failed', e); }

function gid(id){ return document.getElementById(id); }

} })(); </script>

</body>
</html>
