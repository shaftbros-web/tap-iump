<!DOCTYPE html><html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>スマホ用 横スクロールSFシューティング（フル一枚ファイル）</title>
<style>
  :root{--bg:#05070e;--panel:#0d1420;--text:#e6edf3;--muted:#a3b2c7}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui;-webkit-tap-highlight-color:transparent;overflow:hidden}
  /* キャンバスは常に画面いっぱい */
  canvas{position:absolute;inset:0;width:100vw;height:100vh;display:block;touch-action:none;z-index:0;background:#061123}
  /* HUD */
  #hud{position:fixed;left:calc(env(safe-area-inset-left) + 10px);top:calc(env(safe-area-inset-top) + 10px);background:rgba(13,20,32,.75);backdrop-filter:blur(6px);border:1px solid #223048;border-radius:12px;padding:6px 10px;font-size:14px;display:flex;gap:10px;align-items:center;z-index:20}
  #hud b{font-weight:700}
  #err{position:fixed;left:calc(env(safe-area-inset-left) + 10px);top:calc(env(safe-area-inset-top) + 60px);background:#7f1d1d;color:#fee2e2;padding:10px 12px;border-radius:8px;display:none;z-index:21;max-width:92vw}
  /* 操作UI（前面） */
  #controls{position:fixed;inset:0;pointer-events:none;z-index:15}
  #stick{position:fixed;left:calc(env(safe-area-inset-left) + 16px);bottom:calc(env(safe-area-inset-bottom) + 16px);width:clamp(96px,23vmin,180px);height:clamp(96px,23vmin,180px);border-radius:50%;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.2);pointer-events:auto}
  #stickKnob{position:absolute;left:50%;top:50%;width:48%;height:48%;transform:translate(-50%,-50%);border-radius:50%;background:rgba(125,211,252,0.35);border:1px solid rgba(125,211,252,0.8)}
  #fire{position:fixed;right:calc(env(safe-area-inset-right) + 16px);bottom:calc(env(safe-area-inset-bottom) + 18px);width:clamp(80px,20vmin,160px);height:clamp(80px,20vmin,160px);border-radius:50%;display:grid;place-items:center;background:rgba(248,113,113,0.85);border:1px solid rgba(248,113,113,1);color:#fff;font-weight:800;letter-spacing:.5px;text-shadow:0 1px 2px rgba(0,0,0,.5);pointer-events:auto;user-select:none}
  #fire.pressed{filter:brightness(1.15)}
  /* スタートオーバーレイ */
  #startOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:grid;place-items:center;z-index:25}
  #startOverlay .card{pointer-events:auto;background:#0d1420cc;border:1px solid #223048;border-radius:16px;padding:18px 20px;text-align:center}
  #startOverlay h1{margin:0 0 10px 0;font:700 28px system-ui}
  #startOverlay p{margin:6px 0 12px 0;color:var(--muted)}
  #btnStart{background:#0b1220;border:1px solid #223048;color:var(--text);border-radius:12px;padding:10px 16px;font-size:16px;cursor:pointer}
</style>
</head>
<body>
<canvas id="cv"></canvas>
<div id="hud">状態: <b id="state">title</b>｜スコア: <b id="score">0</b>｜残機: <b id="lives">3</b></div>
<div id="err"></div>
<div id="controls">
  <div id="stick"><div id="stickKnob"></div></div>
  <div id="fire">FIRE</div>
</div>
<div id="startOverlay">
  <div class="card">
    <h1>SF SHOOTER</h1>
    <p>左の丸：移動　右の丸：ショット（長押しで連射）</p>
    <button id="btnStart">▶ 開始</button>
  </div>
</div>
<script>
'use strict';
(function(){
  // ===== 取得 =====
  const cv=document.getElementById('cv');
  const cx=cv.getContext('2d',{alpha:false});
  const HUD={ state:gid('state'), score:gid('score'), lives:gid('lives') };
  const errBox=document.getElementById('err');
  const stick=document.getElementById('stick');
  const knob=document.getElementById('stickKnob');
  const fireBtn=document.getElementById('fire');
  const startOverlay=document.getElementById('startOverlay');
  const startBtn=document.getElementById('btnStart');
  function showErr(msg){ errBox.style.display='block'; errBox.textContent=String(msg); }// === エラーフック（スマホ単体でエラーを画面に表示） === window.onerror = function(message, source, lineno, colno, error){ try{ const text = JS Error: ${message} @ ${lineno}:${colno}; showErr(text); // 簡易ログ履歴（追記表示） const p = document.createElement('div'); p.style.marginTop = '6px'; p.style.fontSize = '11px'; p.textContent = (source?source.split('/').pop()+':':'') + (error&&error.stack? error.stack.split(' ')[0] : ''); errBox.appendChild(p); }catch(e){} return true; // 既定のアラートを抑止 }; // Promiseの未処理例外も捕捉 window.onunhandledrejection = function(ev){ showErr('Promise error: ' + (ev && (ev.reason && ev.reason.message || ev.reason))); }; if(!cx){ showErr('Canvas初期化に失敗'); return; }

// ===== 画面・DPR対応 ===== let vw=0,vh=0,dpr=1; function resize(){ dpr=Math.max(1, Math.min(3, window.devicePixelRatio||1)); vw=window.innerWidth; vh=window.innerHeight; const w=Math.floor(vwdpr), h=Math.floor(vhdpr); if(cv.width!==w||cv.height!==h){ cv.width=w; cv.height=h; } cx.setTransform(dpr,0,0,dpr,0,0); } addEventListener('resize', resize); addEventListener('orientationchange', resize); resize();

// ===== 状態 ===== const STATE={title:'title',playing:'playing',paused:'paused',gameover:'gameover',win:'win'}; let state=STATE.title; const setState=s=>{state=s; HUD.state.textContent=s}; let score=0,lives=3;

// ===== ゲームオブジェクト ===== const player={x:vw0.18,y:vh0.5,r:16,speed:380,cd:0}; const bullets=[], enemies=[], enemyBullets=[]; let enemyTimer=0, gameOverTimer=0;

function reset(){ player.x=vw0.18; player.y=vh0.5; player.cd=0; bullets.length=enemies.length=enemyBullets.length=0; enemyTimer=0; score=0; lives=3; HUD.score.textContent=score; HUD.lives.textContent=lives; }

// ===== 入力（バーチャルスティック＋発射） ===== let wantShoot=false, autoFire=false; let joyActive=false, joyDX=0, joyDY=0; function stickCenter(){ const r=stick.getBoundingClientRect(); return {cx:r.left+r.width/2, cy:r.top+r.height/2, rad:Math.min(r.width,r.height)/2}; } function updateKnob(px,py){ const {cx:cX,cy:cY,rad}=stickCenter(); const dx=px-cX, dy=py-cY; const dist=Math.hypot(dx,dy); const lim=rad0.9; const k = dist>lim ? lim/dist : 1; const nx=dxk, ny=dy*k; knob.style.transform=translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px)); joyDX=(dx/lim); joyDY=(dy/lim); const len=Math.min(1, Math.hypot(joyDX,joyDY)); if(len>0){ joyDX/=len; joyDY/=len; } } stick.addEventListener('pointerdown', ev=>{ joyActive=true; stick.setPointerCapture(ev.pointerId); updateKnob(ev.clientX,ev.clientY); ev.preventDefault(); },{passive:false}); stick.addEventListener('pointermove', ev=>{ if(!joyActive) return; updateKnob(ev.clientX,ev.clientY); }); function endStick(){ joyActive=false; joyDX=joyDY=0; knob.style.transform='translate(-50%,-50%)'; } stick.addEventListener('pointerup', endStick); stick.addEventListener('pointercancel', endStick); stick.addEventListener('pointerleave', endStick); fireBtn.addEventListener('pointerdown', ev=>{ fireBtn.classList.add('pressed'); wantShoot=true; autoFire=true; ev.preventDefault(); },{passive:false}); function endFire(){ fireBtn.classList.remove('pressed'); autoFire=false; } fireBtn.addEventListener('pointerup', endFire); fireBtn.addEventListener('pointercancel', endFire); fireBtn.addEventListener('pointerleave', endFire); document.addEventListener('visibilitychange',()=>{ if(document.hidden && state===STATE.playing) setState(STATE.paused); });

// ===== ループ ===== let last=performance.now(); function loop(now){ const dt=Math.min(0.033, Math.max(0.001,(now-last)/1000)); last=now; if(state===STATE.playing) update(dt); draw(); requestAnimationFrame(loop); } requestAnimationFrame(loop);

// ===== 更新 ===== function update(dt){ // 移動 const dead=0.18; let up=false,down=false,left=false,right=false; if(joyActive){ up=(joyDY<-dead); down=(joyDY>dead); left=(joyDX<-dead); right=(joyDX>dead); } const v=player.speed*(joyActive?Math.min(1,Math.hypot(joyDX,joyDY)):1)dt; if(up) player.y-=v; if(down) player.y+=v; if(left) player.x-=v; if(right) player.x+=v; player.x=Math.max(player.r,Math.min(vw0.8,player.x)); player.y=Math.max(player.r,Math.min(vh-player.r,player.y));

// 自弾
player.cd-=dt; if((autoFire||wantShoot)&&player.cd<=0){ bullets.push({x:player.x+player.r+2,y:player.y,vx:600,vy:0,r:5,life:1.2}); player.cd=autoFire?0.12:0.2; wantShoot=false; }
for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0||b.x>vw+20) bullets.splice(i,1); }

// 敵出現
enemyTimer-=dt; if(enemyTimer<=0){ enemyTimer=0.7; enemies.push({x:vw+20,y:40+Math.random()*(vh-80),r:14,hp:1,vx:-220}); }
for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.x+=e.vx*dt; if(e.x<-30){ enemies.splice(i,1); continue; }
  // 弾ヒット
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(circleHit(e.x,e.y,e.r, b.x,b.y,b.r)){ bullets.splice(bi,1); e.hp--; if(e.hp<=0){ enemies.splice(i,1); score+=100; HUD.score.textContent=score; } break; } }
  // 体当たり
  if(circleHit(e.x,e.y,e.r, player.x,player.y,player.r)){ enemies.splice(i,1); damage(); }
}

// 敵弾（今回は簡易：たまに前方へ）
if(Math.random()<0.03){ enemyBullets.push({x:vw+10,y:40+Math.random()*(vh-80),vx:-260,vy:(Math.random()-0.5)*60,r:4}); }
for(let i=enemyBullets.length-1;i>=0;i--){ const eb=enemyBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>vw+40||eb.y<-40||eb.y>vh+40){ enemyBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ enemyBullets.splice(i,1); damage(); } }

if(state===STATE.gameover){ gameOverTimer+=dt; if(gameOverTimer>1.2){ setState(STATE.title); startOverlay.style.display='grid'; } }

}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); gameOverTimer=0; } }

// ===== 描画 ===== function draw(){ // 背景（星） cx.fillStyle='#061123'; cx.fillRect(0,0,vw,vh); cx.globalAlpha=.35; for(let x=0;x<vw;x+=24){ for(let y=0;y<vh;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1; // 自機 drawShip(player.x,player.y,player.r,'#7dd3fc'); // 弾 bullets.forEach(b=>drawBullet(b)); // 敵 enemies.forEach(e=>drawEnemy(e)); // 敵弾 enemyBullets.forEach(b=>drawEBullet(b));

if(state===STATE.title) banner('タップで開始','左：スティック 右：ショット');
if(state===STATE.paused) banner('PAUSED','もう一度タップで再開');
if(state===STATE.gameover) banner('GAME OVER','スコア: '+score);
if(state===STATE.win) banner('YOU WIN','スコア: '+score);

}

// ===== 開始（どこを押しても開始できるよう強化） ===== function startGame(){ try{ if(state===STATE.playing) return; if(startOverlay) startOverlay.style.display='none'; reset(); setState(STATE.playing); }catch(e){ showErr('startGame error: '+e.message); } } // できるだけ多くの入力をフック（Android Chrome/Opera 対策） ['click','pointerdown','touchstart','keydown'].forEach(type=>{ startOverlay.addEventListener(type, startGame, {passive:true}); document.addEventListener(type, ()=>{ if(state!==STATE.playing) startGame(); }, {passive:true}); }); // 個別要素 startBtn.addEventListener('click', startGame, {passive:true}); cv.addEventListener('pointerdown', startGame, {passive:true}); stick.addEventListener('pointerdown', startGame, {passive:true}); fireBtn.addEventListener('pointerdown', ()=>{ if(state!==STATE.playing) startGame(); }, {passive:true}); // 保険：読み込み後に自動開始（1.5秒待ち） window.addEventListener('load', ()=> setTimeout(()=>{ if(state!==STATE.playing) startGame(); }, 1500));

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh*0.3); cx.textAlign='center'; cx.font='700 40px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html><div id="startOverlay">
  <div class="card">
    <h1>SF SHOOTER</h1>
    <p>左の丸：移動　右の丸：ショット（長押しで連射）</p>
    <button id="btnStart">▶ 開始</button>
  </div>
</div>
<script>
'use strict';
(function(){
  // ===== 取得 =====
  const cv=document.getElementById('cv');
  const cx=cv.getContext('2d',{alpha:false});
  const HUD={ state:gid('state'), score:gid('score'), lives:gid('lives') };
  const errBox=document.getElementById('err');
  const stick=document.getElementById('stick');
  const knob=document.getElementById('stickKnob');
  const fireBtn=document.getElementById('fire');
  const startOverlay=document.getElementById('startOverlay');
  const startBtn=document.getElementById('btnStart');
  function showErr(msg){ errBox.style.display='block'; errBox.textContent=String(msg); }// === エラーフック（スマホ単体でエラーを画面に表示） === window.onerror = function(message, source, lineno, colno, error){ try{ const text = JS Error: ${message} @ ${lineno}:${colno}; showErr(text); // 簡易ログ履歴（追記表示） const p = document.createElement('div'); p.style.marginTop = '6px'; p.style.fontSize = '11px'; p.textContent = (source?source.split('/').pop()+':':'') + (error&&error.stack? error.stack.split(' ')[0] : ''); errBox.appendChild(p); }catch(e){} return true; // 既定のアラートを抑止 }; // Promiseの未処理例外も捕捉 window.onunhandledrejection = function(ev){ showErr('Promise error: ' + (ev && (ev.reason && ev.reason.message || ev.reason))); }; if(!cx){ showErr('Canvas初期化に失敗'); return; }

// ===== 画面・DPR対応 ===== let vw=0,vh=0,dpr=1; function resize(){ dpr=Math.max(1, Math.min(3, window.devicePixelRatio||1)); vw=window.innerWidth; vh=window.innerHeight; const w=Math.floor(vwdpr), h=Math.floor(vhdpr); if(cv.width!==w||cv.height!==h){ cv.width=w; cv.height=h; } cx.setTransform(dpr,0,0,dpr,0,0); } addEventListener('resize', resize); addEventListener('orientationchange', resize); resize();

// ===== 状態 ===== const STATE={title:'title',playing:'playing',paused:'paused',gameover:'gameover',win:'win'}; let state=STATE.title; const setState=s=>{state=s; HUD.state.textContent=s}; let score=0,lives=3;

// ===== ゲームオブジェクト ===== const player={x:vw0.18,y:vh0.5,r:16,speed:380,cd:0}; const bullets=[], enemies=[], enemyBullets=[]; let enemyTimer=0, gameOverTimer=0;

function reset(){ player.x=vw0.18; player.y=vh0.5; player.cd=0; bullets.length=enemies.length=enemyBullets.length=0; enemyTimer=0; score=0; lives=3; HUD.score.textContent=score; HUD.lives.textContent=lives; }

// ===== 入力（バーチャルスティック＋発射） ===== let wantShoot=false, autoFire=false; let joyActive=false, joyDX=0, joyDY=0; function stickCenter(){ const r=stick.getBoundingClientRect(); return {cx:r.left+r.width/2, cy:r.top+r.height/2, rad:Math.min(r.width,r.height)/2}; } function updateKnob(px,py){ const {cx:cX,cy:cY,rad}=stickCenter(); const dx=px-cX, dy=py-cY; const dist=Math.hypot(dx,dy); const lim=rad0.9; const k = dist>lim ? lim/dist : 1; const nx=dxk, ny=dy*k; knob.style.transform=translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px)); joyDX=(dx/lim); joyDY=(dy/lim); const len=Math.min(1, Math.hypot(joyDX,joyDY)); if(len>0){ joyDX/=len; joyDY/=len; } } stick.addEventListener('pointerdown', ev=>{ joyActive=true; stick.setPointerCapture(ev.pointerId); updateKnob(ev.clientX,ev.clientY); ev.preventDefault(); },{passive:false}); stick.addEventListener('pointermove', ev=>{ if(!joyActive) return; updateKnob(ev.clientX,ev.clientY); }); function endStick(){ joyActive=false; joyDX=joyDY=0; knob.style.transform='translate(-50%,-50%)'; } stick.addEventListener('pointerup', endStick); stick.addEventListener('pointercancel', endStick); stick.addEventListener('pointerleave', endStick); fireBtn.addEventListener('pointerdown', ev=>{ fireBtn.classList.add('pressed'); wantShoot=true; autoFire=true; ev.preventDefault(); },{passive:false}); function endFire(){ fireBtn.classList.remove('pressed'); autoFire=false; } fireBtn.addEventListener('pointerup', endFire); fireBtn.addEventListener('pointercancel', endFire); fireBtn.addEventListener('pointerleave', endFire); document.addEventListener('visibilitychange',()=>{ if(document.hidden && state===STATE.playing) setState(STATE.paused); });

// ===== ループ ===== let last=performance.now(); function loop(now){ const dt=Math.min(0.033, Math.max(0.001,(now-last)/1000)); last=now; if(state===STATE.playing) update(dt); draw(); requestAnimationFrame(loop); } requestAnimationFrame(loop);

// ===== 更新 ===== function update(dt){ // 移動 const dead=0.18; let up=false,down=false,left=false,right=false; if(joyActive){ up=(joyDY<-dead); down=(joyDY>dead); left=(joyDX<-dead); right=(joyDX>dead); } const v=player.speed*(joyActive?Math.min(1,Math.hypot(joyDX,joyDY)):1)dt; if(up) player.y-=v; if(down) player.y+=v; if(left) player.x-=v; if(right) player.x+=v; player.x=Math.max(player.r,Math.min(vw0.8,player.x)); player.y=Math.max(player.r,Math.min(vh-player.r,player.y));

// 自弾
player.cd-=dt; if((autoFire||wantShoot)&&player.cd<=0){ bullets.push({x:player.x+player.r+2,y:player.y,vx:600,vy:0,r:5,life:1.2}); player.cd=autoFire?0.12:0.2; wantShoot=false; }
for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0||b.x>vw+20) bullets.splice(i,1); }

// 敵出現
enemyTimer-=dt; if(enemyTimer<=0){ enemyTimer=0.7; enemies.push({x:vw+20,y:40+Math.random()*(vh-80),r:14,hp:1,vx:-220}); }
for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.x+=e.vx*dt; if(e.x<-30){ enemies.splice(i,1); continue; }
  // 弾ヒット
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(circleHit(e.x,e.y,e.r, b.x,b.y,b.r)){ bullets.splice(bi,1); e.hp--; if(e.hp<=0){ enemies.splice(i,1); score+=100; HUD.score.textContent=score; } break; } }
  // 体当たり
  if(circleHit(e.x,e.y,e.r, player.x,player.y,player.r)){ enemies.splice(i,1); damage(); }
}

// 敵弾（今回は簡易：たまに前方へ）
if(Math.random()<0.03){ enemyBullets.push({x:vw+10,y:40+Math.random()*(vh-80),vx:-260,vy:(Math.random()-0.5)*60,r:4}); }
for(let i=enemyBullets.length-1;i>=0;i--){ const eb=enemyBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>vw+40||eb.y<-40||eb.y>vh+40){ enemyBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ enemyBullets.splice(i,1); damage(); } }

if(state===STATE.gameover){ gameOverTimer+=dt; if(gameOverTimer>1.2){ setState(STATE.title); startOverlay.style.display='grid'; } }

}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); gameOverTimer=0; } }

// ===== 描画 ===== function draw(){ // 背景（星） cx.fillStyle='#061123'; cx.fillRect(0,0,vw,vh); cx.globalAlpha=.35; for(let x=0;x<vw;x+=24){ for(let y=0;y<vh;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1; // 自機 drawShip(player.x,player.y,player.r,'#7dd3fc'); // 弾 bullets.forEach(b=>drawBullet(b)); // 敵 enemies.forEach(e=>drawEnemy(e)); // 敵弾 enemyBullets.forEach(b=>drawEBullet(b));

if(state===STATE.title) banner('タップで開始','左：スティック 右：ショット');
if(state===STATE.paused) banner('PAUSED','もう一度タップで再開');
if(state===STATE.gameover) banner('GAME OVER','スコア: '+score);
if(state===STATE.win) banner('YOU WIN','スコア: '+score);

}

// ===== 開始（どこを押しても開始できるよう強化） ===== function startGame(){ try{ if(state===STATE.playing) return; if(startOverlay) startOverlay.style.display='none'; reset(); setState(STATE.playing); }catch(e){ showErr('startGame error: '+e.message); } } // できるだけ多くの入力をフック（Android Chrome/Opera 対策） ['click','pointerdown','touchstart','keydown'].forEach(type=>{ startOverlay.addEventListener(type, startGame, {passive:true}); document.addEventListener(type, ()=>{ if(state!==STATE.playing) startGame(); }, {passive:true}); }); // 個別要素 startBtn.addEventListener('click', startGame, {passive:true}); cv.addEventListener('pointerdown', startGame, {passive:true}); stick.addEventListener('pointerdown', startGame, {passive:true}); fireBtn.addEventListener('pointerdown', ()=>{ if(state!==STATE.playing) startGame(); }, {passive:true}); // 保険：読み込み後に自動開始（1.5秒待ち） window.addEventListener('load', ()=> setTimeout(()=>{ if(state!==STATE.playing) startGame(); }, 1500));

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh*0.3); cx.textAlign='center'; cx.font='700 40px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html><div id="startOverlay">
  <div class="card">
    <h1>SF SHOOTER</h1>
    <p>左の丸：移動　右の丸：ショット（長押しで連射）</p>
    <button id="btnStart">▶ 開始</button>
  </div>
</div>
<script>
'use strict';
(function(){
  // ===== 取得 =====
  const cv=document.getElementById('cv');
  const cx=cv.getContext('2d',{alpha:false});
  const HUD={ state:gid('state'), score:gid('score'), lives:gid('lives') };
  const errBox=document.getElementById('err');
  const stick=document.getElementById('stick');
  const knob=document.getElementById('stickKnob');
  const fireBtn=document.getElementById('fire');
  const startOverlay=document.getElementById('startOverlay');
  const startBtn=document.getElementById('btnStart');
  function showErr(msg){ errBox.style.display='block'; errBox.textContent=String(msg); }
  if(!cx){ showErr('Canvas初期化に失敗'); return; }// ===== 画面・DPR対応 ===== let vw=0,vh=0,dpr=1; function resize(){ dpr=Math.max(1, Math.min(3, window.devicePixelRatio||1)); vw=window.innerWidth; vh=window.innerHeight; const w=Math.floor(vwdpr), h=Math.floor(vhdpr); if(cv.width!==w||cv.height!==h){ cv.width=w; cv.height=h; } cx.setTransform(dpr,0,0,dpr,0,0); } addEventListener('resize', resize); addEventListener('orientationchange', resize); resize();

// ===== 状態 ===== const STATE={title:'title',playing:'playing',paused:'paused',gameover:'gameover',win:'win'}; let state=STATE.title; const setState=s=>{state=s; HUD.state.textContent=s}; let score=0,lives=3;

// ===== ゲームオブジェクト ===== const player={x:vw0.18,y:vh0.5,r:16,speed:380,cd:0}; const bullets=[], enemies=[], enemyBullets=[]; let enemyTimer=0, gameOverTimer=0;

function reset(){ player.x=vw0.18; player.y=vh0.5; player.cd=0; bullets.length=enemies.length=enemyBullets.length=0; enemyTimer=0; score=0; lives=3; HUD.score.textContent=score; HUD.lives.textContent=lives; }

// ===== 入力（バーチャルスティック＋発射） ===== let wantShoot=false, autoFire=false; let joyActive=false, joyDX=0, joyDY=0; function stickCenter(){ const r=stick.getBoundingClientRect(); return {cx:r.left+r.width/2, cy:r.top+r.height/2, rad:Math.min(r.width,r.height)/2}; } function updateKnob(px,py){ const {cx:cX,cy:cY,rad}=stickCenter(); const dx=px-cX, dy=py-cY; const dist=Math.hypot(dx,dy); const lim=rad0.9; const k = dist>lim ? lim/dist : 1; const nx=dxk, ny=dy*k; knob.style.transform=translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px)); joyDX=(dx/lim); joyDY=(dy/lim); const len=Math.min(1, Math.hypot(joyDX,joyDY)); if(len>0){ joyDX/=len; joyDY/=len; } } stick.addEventListener('pointerdown', ev=>{ joyActive=true; stick.setPointerCapture(ev.pointerId); updateKnob(ev.clientX,ev.clientY); ev.preventDefault(); },{passive:false}); stick.addEventListener('pointermove', ev=>{ if(!joyActive) return; updateKnob(ev.clientX,ev.clientY); }); function endStick(){ joyActive=false; joyDX=joyDY=0; knob.style.transform='translate(-50%,-50%)'; } stick.addEventListener('pointerup', endStick); stick.addEventListener('pointercancel', endStick); stick.addEventListener('pointerleave', endStick); fireBtn.addEventListener('pointerdown', ev=>{ fireBtn.classList.add('pressed'); wantShoot=true; autoFire=true; ev.preventDefault(); },{passive:false}); function endFire(){ fireBtn.classList.remove('pressed'); autoFire=false; } fireBtn.addEventListener('pointerup', endFire); fireBtn.addEventListener('pointercancel', endFire); fireBtn.addEventListener('pointerleave', endFire); document.addEventListener('visibilitychange',()=>{ if(document.hidden && state===STATE.playing) setState(STATE.paused); });

// ===== ループ ===== let last=performance.now(); function loop(now){ const dt=Math.min(0.033, Math.max(0.001,(now-last)/1000)); last=now; if(state===STATE.playing) update(dt); draw(); requestAnimationFrame(loop); } requestAnimationFrame(loop);

// ===== 更新 ===== function update(dt){ // 移動 const dead=0.18; let up=false,down=false,left=false,right=false; if(joyActive){ up=(joyDY<-dead); down=(joyDY>dead); left=(joyDX<-dead); right=(joyDX>dead); } const v=player.speed*(joyActive?Math.min(1,Math.hypot(joyDX,joyDY)):1)dt; if(up) player.y-=v; if(down) player.y+=v; if(left) player.x-=v; if(right) player.x+=v; player.x=Math.max(player.r,Math.min(vw0.8,player.x)); player.y=Math.max(player.r,Math.min(vh-player.r,player.y));

// 自弾
player.cd-=dt; if((autoFire||wantShoot)&&player.cd<=0){ bullets.push({x:player.x+player.r+2,y:player.y,vx:600,vy:0,r:5,life:1.2}); player.cd=autoFire?0.12:0.2; wantShoot=false; }
for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0||b.x>vw+20) bullets.splice(i,1); }

// 敵出現
enemyTimer-=dt; if(enemyTimer<=0){ enemyTimer=0.7; enemies.push({x:vw+20,y:40+Math.random()*(vh-80),r:14,hp:1,vx:-220}); }
for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.x+=e.vx*dt; if(e.x<-30){ enemies.splice(i,1); continue; }
  // 弾ヒット
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(circleHit(e.x,e.y,e.r, b.x,b.y,b.r)){ bullets.splice(bi,1); e.hp--; if(e.hp<=0){ enemies.splice(i,1); score+=100; HUD.score.textContent=score; } break; } }
  // 体当たり
  if(circleHit(e.x,e.y,e.r, player.x,player.y,player.r)){ enemies.splice(i,1); damage(); }
}

// 敵弾（今回は簡易：たまに前方へ）
if(Math.random()<0.03){ enemyBullets.push({x:vw+10,y:40+Math.random()*(vh-80),vx:-260,vy:(Math.random()-0.5)*60,r:4}); }
for(let i=enemyBullets.length-1;i>=0;i--){ const eb=enemyBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>vw+40||eb.y<-40||eb.y>vh+40){ enemyBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ enemyBullets.splice(i,1); damage(); } }

if(state===STATE.gameover){ gameOverTimer+=dt; if(gameOverTimer>1.2){ setState(STATE.title); startOverlay.style.display='grid'; } }

}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); gameOverTimer=0; } }

// ===== 描画 ===== function draw(){ // 背景（星） cx.fillStyle='#061123'; cx.fillRect(0,0,vw,vh); cx.globalAlpha=.35; for(let x=0;x<vw;x+=24){ for(let y=0;y<vh;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1; // 自機 drawShip(player.x,player.y,player.r,'#7dd3fc'); // 弾 bullets.forEach(b=>drawBullet(b)); // 敵 enemies.forEach(e=>drawEnemy(e)); // 敵弾 enemyBullets.forEach(b=>drawEBullet(b));

if(state===STATE.title) banner('タップで開始','左：スティック 右：ショット');
if(state===STATE.paused) banner('PAUSED','もう一度タップで再開');
if(state===STATE.gameover) banner('GAME OVER','スコア: '+score);
if(state===STATE.win) banner('YOU WIN','スコア: '+score);

}

// ===== 開始（どこを押しても開始できるよう強化） ===== function startGame(){ try{ if(state===STATE.playing) return; if(startOverlay) startOverlay.style.display='none'; reset(); setState(STATE.playing); }catch(e){ showErr('startGame error: '+e.message); } } // できるだけ多くの入力をフック（Android Chrome/Opera 対策） ['click','pointerdown','touchstart','keydown'].forEach(type=>{ startOverlay.addEventListener(type, startGame, {passive:true}); document.addEventListener(type, ()=>{ if(state!==STATE.playing) startGame(); }, {passive:true}); }); // 個別要素 startBtn.addEventListener('click', startGame, {passive:true}); cv.addEventListener('pointerdown', startGame, {passive:true}); stick.addEventListener('pointerdown', startGame, {passive:true}); fireBtn.addEventListener('pointerdown', ()=>{ if(state!==STATE.playing) startGame(); }, {passive:true}); // 保険：読み込み後に自動開始（1.5秒待ち） window.addEventListener('load', ()=> setTimeout(()=>{ if(state!==STATE.playing) startGame(); }, 1500));

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh*0.3); cx.textAlign='center'; cx.font='700 40px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html><div id="startOverlay">
  <div class="card">
    <h1>SF SHOOTER</h1>
    <p>左の丸：移動　右の丸：ショット（長押しで連射）</p>
    <button id="btnStart">▶ 開始</button>
  </div>
</div>
<script>
'use strict';
(function(){
  // ===== 取得 =====
  const cv=document.getElementById('cv');
  const cx=cv.getContext('2d',{alpha:false});
  const HUD={ state:gid('state'), score:gid('score'), lives:gid('lives') };
  const errBox=document.getElementById('err');
  const stick=document.getElementById('stick');
  const knob=document.getElementById('stickKnob');
  const fireBtn=document.getElementById('fire');
  const startOverlay=document.getElementById('startOverlay');
  const startBtn=document.getElementById('btnStart');
  function showErr(msg){ errBox.style.display='block'; errBox.textContent=String(msg); }
  if(!cx){ showErr('Canvas初期化に失敗'); return; }// ===== 画面・DPR対応 ===== let vw=0,vh=0,dpr=1; function resize(){ dpr=Math.max(1, Math.min(3, window.devicePixelRatio||1)); vw=window.innerWidth; vh=window.innerHeight; const w=Math.floor(vwdpr), h=Math.floor(vhdpr); if(cv.width!==w||cv.height!==h){ cv.width=w; cv.height=h; } cx.setTransform(dpr,0,0,dpr,0,0); } addEventListener('resize', resize); addEventListener('orientationchange', resize); resize();

// ===== 状態 ===== const STATE={title:'title',playing:'playing',paused:'paused',gameover:'gameover',win:'win'}; let state=STATE.title; const setState=s=>{state=s; HUD.state.textContent=s}; let score=0,lives=3;

// ===== ゲームオブジェクト ===== const player={x:vw0.18,y:vh0.5,r:16,speed:380,cd:0}; const bullets=[], enemies=[], enemyBullets=[]; let enemyTimer=0, gameOverTimer=0;

function reset(){ player.x=vw0.18; player.y=vh0.5; player.cd=0; bullets.length=enemies.length=enemyBullets.length=0; enemyTimer=0; score=0; lives=3; HUD.score.textContent=score; HUD.lives.textContent=lives; }

// ===== 入力（バーチャルスティック＋発射） ===== let wantShoot=false, autoFire=false; let joyActive=false, joyDX=0, joyDY=0; function stickCenter(){ const r=stick.getBoundingClientRect(); return {cx:r.left+r.width/2, cy:r.top+r.height/2, rad:Math.min(r.width,r.height)/2}; } function updateKnob(px,py){ const {cx:cX,cy:cY,rad}=stickCenter(); const dx=px-cX, dy=py-cY; const dist=Math.hypot(dx,dy); const lim=rad0.9; const k = dist>lim ? lim/dist : 1; const nx=dxk, ny=dy*k; knob.style.transform=translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px)); joyDX=(dx/lim); joyDY=(dy/lim); const len=Math.min(1, Math.hypot(joyDX,joyDY)); if(len>0){ joyDX/=len; joyDY/=len; } } stick.addEventListener('pointerdown', ev=>{ joyActive=true; stick.setPointerCapture(ev.pointerId); updateKnob(ev.clientX,ev.clientY); ev.preventDefault(); },{passive:false}); stick.addEventListener('pointermove', ev=>{ if(!joyActive) return; updateKnob(ev.clientX,ev.clientY); }); function endStick(){ joyActive=false; joyDX=joyDY=0; knob.style.transform='translate(-50%,-50%)'; } stick.addEventListener('pointerup', endStick); stick.addEventListener('pointercancel', endStick); stick.addEventListener('pointerleave', endStick); fireBtn.addEventListener('pointerdown', ev=>{ fireBtn.classList.add('pressed'); wantShoot=true; autoFire=true; ev.preventDefault(); },{passive:false}); function endFire(){ fireBtn.classList.remove('pressed'); autoFire=false; } fireBtn.addEventListener('pointerup', endFire); fireBtn.addEventListener('pointercancel', endFire); fireBtn.addEventListener('pointerleave', endFire); document.addEventListener('visibilitychange',()=>{ if(document.hidden && state===STATE.playing) setState(STATE.paused); });

// ===== ループ ===== let last=performance.now(); function loop(now){ const dt=Math.min(0.033, Math.max(0.001,(now-last)/1000)); last=now; if(state===STATE.playing) update(dt); draw(); requestAnimationFrame(loop);

// どこでもタップで開始（オーバーレイが押せない端末対策） cv.addEventListener('pointerdown', ()=>{ if(state!==STATE.playing){ if(startOverlay) startOverlay.style.display='none'; reset(); setState(STATE.playing); } }, {passive:true}); } requestAnimationFrame(loop);

// ===== 更新 ===== function update(dt){ // 移動 const dead=0.18; let up=false,down=false,left=false,right=false; if(joyActive){ up=(joyDY<-dead); down=(joyDY>dead); left=(joyDX<-dead); right=(joyDX>dead); } const v=player.speed*(joyActive?Math.min(1,Math.hypot(joyDX,joyDY)):1)dt; if(up) player.y-=v; if(down) player.y+=v; if(left) player.x-=v; if(right) player.x+=v; player.x=Math.max(player.r,Math.min(vw0.8,player.x)); player.y=Math.max(player.r,Math.min(vh-player.r,player.y));

// 自弾
player.cd-=dt; if((autoFire||wantShoot)&&player.cd<=0){ bullets.push({x:player.x+player.r+2,y:player.y,vx:600,vy:0,r:5,life:1.2}); player.cd=autoFire?0.12:0.2; wantShoot=false; }
for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0||b.x>vw+20) bullets.splice(i,1); }

// 敵出現
enemyTimer-=dt; if(enemyTimer<=0){ enemyTimer=0.7; enemies.push({x:vw+20,y:40+Math.random()*(vh-80),r:14,hp:1,vx:-220}); }
for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.x+=e.vx*dt; if(e.x<-30){ enemies.splice(i,1); continue; }
  // 弾ヒット
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(circleHit(e.x,e.y,e.r, b.x,b.y,b.r)){ bullets.splice(bi,1); e.hp--; if(e.hp<=0){ enemies.splice(i,1); score+=100; HUD.score.textContent=score; } break; } }
  // 体当たり
  if(circleHit(e.x,e.y,e.r, player.x,player.y,player.r)){ enemies.splice(i,1); damage(); }
}

// 敵弾（今回は簡易：たまに前方へ）
if(Math.random()<0.03){ enemyBullets.push({x:vw+10,y:40+Math.random()*(vh-80),vx:-260,vy:(Math.random()-0.5)*60,r:4}); }
for(let i=enemyBullets.length-1;i>=0;i--){ const eb=enemyBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>vw+40||eb.y<-40||eb.y>vh+40){ enemyBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ enemyBullets.splice(i,1); damage(); } }

if(state===STATE.gameover){ gameOverTimer+=dt; if(gameOverTimer>1.2){ setState(STATE.title); startOverlay.style.display='grid'; } }

}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); gameOverTimer=0; } }

// ===== 描画 ===== function draw(){ // 背景（星） cx.fillStyle='#061123'; cx.fillRect(0,0,vw,vh); cx.globalAlpha=.35; for(let x=0;x<vw;x+=24){ for(let y=0;y<vh;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1; // 自機 drawShip(player.x,player.y,player.r,'#7dd3fc'); // 弾 bullets.forEach(b=>drawBullet(b)); // 敵 enemies.forEach(e=>drawEnemy(e)); // 敵弾 enemyBullets.forEach(b=>drawEBullet(b));

if(state===STATE.title) banner('タップで開始','左：スティック 右：ショット');
if(state===STATE.paused) banner('PAUSED','もう一度タップで再開');
if(state===STATE.gameover) banner('GAME OVER','スコア: '+score);
if(state===STATE.win) banner('YOU WIN','スコア: '+score);

}

// ===== 開始（どこを押しても開始できるよう強化） ===== function startGame(){ if(state===STATE.playing) return; if(startOverlay) startOverlay.style.display='none'; reset(); setState(STATE.playing); } // 明示ボタン startBtn.addEventListener('click', startGame, {passive:true}); // オーバーレイどこでも startOverlay.addEventListener('click', startGame, {passive:true}); // キャンバス・操作UIからも開始 cv.addEventListener('pointerdown', startGame, {passive:true}); stick.addEventListener('pointerdown', startGame, {passive:true}); fireBtn.addEventListener('pointerdown', (e)=>{ if(state!==STATE.playing) startGame(); /* その後の処理は既存が実行 */ }, {passive:true}); setState(STATE.playing); }, {passive:true});

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh*0.3); cx.textAlign='center'; cx.font='700 40px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html><div id="startOverlay">
  <div class="card">
    <h1>SF SHOOTER</h1>
    <p>左の丸：移動　右の丸：ショット（長押しで連射）</p>
    <button id="btnStart">▶ 開始</button>
  </div>
</div>
<script>
'use strict';
(function(){
  // ===== 取得 =====
  const cv=document.getElementById('cv');
  const cx=cv.getContext('2d',{alpha:false});
  const HUD={ state:gid('state'), score:gid('score'), lives:gid('lives') };
  const errBox=document.getElementById('err');
  const stick=document.getElementById('stick');
  const knob=document.getElementById('stickKnob');
  const fireBtn=document.getElementById('fire');
  const startOverlay=document.getElementById('startOverlay');
  const startBtn=document.getElementById('btnStart');
  function showErr(msg){ errBox.style.display='block'; errBox.textContent=String(msg); }
  if(!cx){ showErr('Canvas初期化に失敗'); return; }// ===== 画面・DPR対応 ===== let vw=0,vh=0,dpr=1; function resize(){ dpr=Math.max(1, Math.min(3, window.devicePixelRatio||1)); vw=window.innerWidth; vh=window.innerHeight; const w=Math.floor(vwdpr), h=Math.floor(vhdpr); if(cv.width!==w||cv.height!==h){ cv.width=w; cv.height=h; } cx.setTransform(dpr,0,0,dpr,0,0); } addEventListener('resize', resize); addEventListener('orientationchange', resize); resize();

// ===== 状態 ===== const STATE={title:'title',playing:'playing',paused:'paused',gameover:'gameover',win:'win'}; let state=STATE.title; const setState=s=>{state=s; HUD.state.textContent=s}; let score=0,lives=3;

// ===== ゲームオブジェクト ===== const player={x:vw0.18,y:vh0.5,r:16,speed:380,cd:0}; const bullets=[], enemies=[], enemyBullets=[]; let enemyTimer=0, gameOverTimer=0;

function reset(){ player.x=vw0.18; player.y=vh0.5; player.cd=0; bullets.length=enemies.length=enemyBullets.length=0; enemyTimer=0; score=0; lives=3; HUD.score.textContent=score; HUD.lives.textContent=lives; }

// ===== 入力（バーチャルスティック＋発射） ===== let wantShoot=false, autoFire=false; let joyActive=false, joyDX=0, joyDY=0; function stickCenter(){ const r=stick.getBoundingClientRect(); return {cx:r.left+r.width/2, cy:r.top+r.height/2, rad:Math.min(r.width,r.height)/2}; } function updateKnob(px,py){ const {cx:cX,cy:cY,rad}=stickCenter(); const dx=px-cX, dy=py-cY; const dist=Math.hypot(dx,dy); const lim=rad0.9; const k = dist>lim ? lim/dist : 1; const nx=dxk, ny=dy*k; knob.style.transform=translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px)); joyDX=(dx/lim); joyDY=(dy/lim); const len=Math.min(1, Math.hypot(joyDX,joyDY)); if(len>0){ joyDX/=len; joyDY/=len; } } stick.addEventListener('pointerdown', ev=>{ joyActive=true; stick.setPointerCapture(ev.pointerId); updateKnob(ev.clientX,ev.clientY); ev.preventDefault(); },{passive:false}); stick.addEventListener('pointermove', ev=>{ if(!joyActive) return; updateKnob(ev.clientX,ev.clientY); }); function endStick(){ joyActive=false; joyDX=joyDY=0; knob.style.transform='translate(-50%,-50%)'; } stick.addEventListener('pointerup', endStick); stick.addEventListener('pointercancel', endStick); stick.addEventListener('pointerleave', endStick); fireBtn.addEventListener('pointerdown', ev=>{ fireBtn.classList.add('pressed'); wantShoot=true; autoFire=true; ev.preventDefault(); },{passive:false}); function endFire(){ fireBtn.classList.remove('pressed'); autoFire=false; } fireBtn.addEventListener('pointerup', endFire); fireBtn.addEventListener('pointercancel', endFire); fireBtn.addEventListener('pointerleave', endFire); document.addEventListener('visibilitychange',()=>{ if(document.hidden && state===STATE.playing) setState(STATE.paused); });

// ===== ループ ===== let last=performance.now(); function loop(now){ const dt=Math.min(0.033, Math.max(0.001,(now-last)/1000)); last=now; if(state===STATE.playing) update(dt); draw(); requestAnimationFrame(loop);

// どこでもタップで開始（オーバーレイが押せない端末対策） cv.addEventListener('pointerdown', ()=>{ if(state!==STATE.playing){ if(startOverlay) startOverlay.style.display='none'; reset(); setState(STATE.playing); } }, {passive:true}); } requestAnimationFrame(loop);

// ===== 更新 ===== function update(dt){ // 移動 const dead=0.18; let up=false,down=false,left=false,right=false; if(joyActive){ up=(joyDY<-dead); down=(joyDY>dead); left=(joyDX<-dead); right=(joyDX>dead); } const v=player.speed*(joyActive?Math.min(1,Math.hypot(joyDX,joyDY)):1)dt; if(up) player.y-=v; if(down) player.y+=v; if(left) player.x-=v; if(right) player.x+=v; player.x=Math.max(player.r,Math.min(vw0.8,player.x)); player.y=Math.max(player.r,Math.min(vh-player.r,player.y));

// 自弾
player.cd-=dt; if((autoFire||wantShoot)&&player.cd<=0){ bullets.push({x:player.x+player.r+2,y:player.y,vx:600,vy:0,r:5,life:1.2}); player.cd=autoFire?0.12:0.2; wantShoot=false; }
for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0||b.x>vw+20) bullets.splice(i,1); }

// 敵出現
enemyTimer-=dt; if(enemyTimer<=0){ enemyTimer=0.7; enemies.push({x:vw+20,y:40+Math.random()*(vh-80),r:14,hp:1,vx:-220}); }
for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.x+=e.vx*dt; if(e.x<-30){ enemies.splice(i,1); continue; }
  // 弾ヒット
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(circleHit(e.x,e.y,e.r, b.x,b.y,b.r)){ bullets.splice(bi,1); e.hp--; if(e.hp<=0){ enemies.splice(i,1); score+=100; HUD.score.textContent=score; } break; } }
  // 体当たり
  if(circleHit(e.x,e.y,e.r, player.x,player.y,player.r)){ enemies.splice(i,1); damage(); }
}

// 敵弾（今回は簡易：たまに前方へ）
if(Math.random()<0.03){ enemyBullets.push({x:vw+10,y:40+Math.random()*(vh-80),vx:-260,vy:(Math.random()-0.5)*60,r:4}); }
for(let i=enemyBullets.length-1;i>=0;i--){ const eb=enemyBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>vw+40||eb.y<-40||eb.y>vh+40){ enemyBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ enemyBullets.splice(i,1); damage(); } }

if(state===STATE.gameover){ gameOverTimer+=dt; if(gameOverTimer>1.2){ setState(STATE.title); startOverlay.style.display='grid'; } }

}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); gameOverTimer=0; } }

// ===== 描画 ===== function draw(){ // 背景（星） cx.fillStyle='#061123'; cx.fillRect(0,0,vw,vh); cx.globalAlpha=.35; for(let x=0;x<vw;x+=24){ for(let y=0;y<vh;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1; // 自機 drawShip(player.x,player.y,player.r,'#7dd3fc'); // 弾 bullets.forEach(b=>drawBullet(b)); // 敵 enemies.forEach(e=>drawEnemy(e)); // 敵弾 enemyBullets.forEach(b=>drawEBullet(b));

if(state===STATE.title) banner('タップで開始','左：スティック 右：ショット');
if(state===STATE.paused) banner('PAUSED','もう一度タップで再開');
if(state===STATE.gameover) banner('GAME OVER','スコア: '+score);
if(state===STATE.win) banner('YOU WIN','スコア: '+score);

}

// ===== 開始（どこを押しても開始できるよう強化） ===== function startGame(){ if(state===STATE.playing) return; if(startOverlay) startOverlay.style.display='none'; reset(); setState(STATE.playing); } // 明示ボタン startBtn.addEventListener('click', startGame, {passive:true}); // オーバーレイどこでも startOverlay.addEventListener('click', startGame, {passive:true}); // キャンバス・操作UIからも開始 cv.addEventListener('pointerdown', startGame, {passive:true}); stick.addEventListener('pointerdown', startGame, {passive:true}); fireBtn.addEventListener('pointerdown', (e)=>{ if(state!==STATE.playing) startGame(); /* その後の処理は既存が実行 */ }, {passive:true}); setState(STATE.playing); }, {passive:true});

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh*0.3); cx.textAlign='center'; cx.font='700 40px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html><div id="startOverlay">
  <div class="card">
    <h1>SF SHOOTER</h1>
    <p>左の丸：移動　右の丸：ショット（長押しで連射）</p>
    <button id="btnStart">▶ 開始</button>
  </div>
</div>
<script>
'use strict';
(function(){
  // ===== 取得 =====
  const cv=document.getElementById('cv');
  const cx=cv.getContext('2d',{alpha:false});
  const HUD={ state:gid('state'), score:gid('score'), lives:gid('lives') };
  const errBox=document.getElementById('err');
  const stick=document.getElementById('stick');
  const knob=document.getElementById('stickKnob');
  const fireBtn=document.getElementById('fire');
  const startOverlay=document.getElementById('startOverlay');
  const startBtn=document.getElementById('btnStart');
  function showErr(msg){ errBox.style.display='block'; errBox.textContent=String(msg); }
  if(!cx){ showErr('Canvas初期化に失敗'); return; }// ===== 画面・DPR対応 ===== let vw=0,vh=0,dpr=1; function resize(){ dpr=Math.max(1, Math.min(3, window.devicePixelRatio||1)); vw=window.innerWidth; vh=window.innerHeight; const w=Math.floor(vwdpr), h=Math.floor(vhdpr); if(cv.width!==w||cv.height!==h){ cv.width=w; cv.height=h; } cx.setTransform(dpr,0,0,dpr,0,0); } addEventListener('resize', resize); addEventListener('orientationchange', resize); resize();

// ===== 状態 ===== const STATE={title:'title',playing:'playing',paused:'paused',gameover:'gameover',win:'win'}; let state=STATE.title; const setState=s=>{state=s; HUD.state.textContent=s}; let score=0,lives=3;

// ===== ゲームオブジェクト ===== const player={x:vw0.18,y:vh0.5,r:16,speed:380,cd:0}; const bullets=[], enemies=[], enemyBullets=[]; let enemyTimer=0, gameOverTimer=0;

function reset(){ player.x=vw0.18; player.y=vh0.5; player.cd=0; bullets.length=enemies.length=enemyBullets.length=0; enemyTimer=0; score=0; lives=3; HUD.score.textContent=score; HUD.lives.textContent=lives; }

// ===== 入力（バーチャルスティック＋発射） ===== let wantShoot=false, autoFire=false; let joyActive=false, joyDX=0, joyDY=0; function stickCenter(){ const r=stick.getBoundingClientRect(); return {cx:r.left+r.width/2, cy:r.top+r.height/2, rad:Math.min(r.width,r.height)/2}; } function updateKnob(px,py){ const {cx:cX,cy:cY,rad}=stickCenter(); const dx=px-cX, dy=py-cY; const dist=Math.hypot(dx,dy); const lim=rad0.9; const k = dist>lim ? lim/dist : 1; const nx=dxk, ny=dy*k; knob.style.transform=translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px)); joyDX=(dx/lim); joyDY=(dy/lim); const len=Math.min(1, Math.hypot(joyDX,joyDY)); if(len>0){ joyDX/=len; joyDY/=len; } } stick.addEventListener('pointerdown', ev=>{ joyActive=true; stick.setPointerCapture(ev.pointerId); updateKnob(ev.clientX,ev.clientY); ev.preventDefault(); },{passive:false}); stick.addEventListener('pointermove', ev=>{ if(!joyActive) return; updateKnob(ev.clientX,ev.clientY); }); function endStick(){ joyActive=false; joyDX=joyDY=0; knob.style.transform='translate(-50%,-50%)'; } stick.addEventListener('pointerup', endStick); stick.addEventListener('pointercancel', endStick); stick.addEventListener('pointerleave', endStick); fireBtn.addEventListener('pointerdown', ev=>{ fireBtn.classList.add('pressed'); wantShoot=true; autoFire=true; ev.preventDefault(); },{passive:false}); function endFire(){ fireBtn.classList.remove('pressed'); autoFire=false; } fireBtn.addEventListener('pointerup', endFire); fireBtn.addEventListener('pointercancel', endFire); fireBtn.addEventListener('pointerleave', endFire); document.addEventListener('visibilitychange',()=>{ if(document.hidden && state===STATE.playing) setState(STATE.paused); });

// ===== ループ ===== let last=performance.now(); function loop(now){ const dt=Math.min(0.033, Math.max(0.001,(now-last)/1000)); last=now; if(state===STATE.playing) update(dt); draw(); requestAnimationFrame(loop);

// どこでもタップで開始（オーバーレイが押せない端末対策） cv.addEventListener('pointerdown', ()=>{ if(state!==STATE.playing){ if(startOverlay) startOverlay.style.display='none'; reset(); setState(STATE.playing); } }, {passive:true}); } requestAnimationFrame(loop);

// ===== 更新 ===== function update(dt){ // 移動 const dead=0.18; let up=false,down=false,left=false,right=false; if(joyActive){ up=(joyDY<-dead); down=(joyDY>dead); left=(joyDX<-dead); right=(joyDX>dead); } const v=player.speed*(joyActive?Math.min(1,Math.hypot(joyDX,joyDY)):1)dt; if(up) player.y-=v; if(down) player.y+=v; if(left) player.x-=v; if(right) player.x+=v; player.x=Math.max(player.r,Math.min(vw0.8,player.x)); player.y=Math.max(player.r,Math.min(vh-player.r,player.y));

// 自弾
player.cd-=dt; if((autoFire||wantShoot)&&player.cd<=0){ bullets.push({x:player.x+player.r+2,y:player.y,vx:600,vy:0,r:5,life:1.2}); player.cd=autoFire?0.12:0.2; wantShoot=false; }
for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0||b.x>vw+20) bullets.splice(i,1); }

// 敵出現
enemyTimer-=dt; if(enemyTimer<=0){ enemyTimer=0.7; enemies.push({x:vw+20,y:40+Math.random()*(vh-80),r:14,hp:1,vx:-220}); }
for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.x+=e.vx*dt; if(e.x<-30){ enemies.splice(i,1); continue; }
  // 弾ヒット
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(circleHit(e.x,e.y,e.r, b.x,b.y,b.r)){ bullets.splice(bi,1); e.hp--; if(e.hp<=0){ enemies.splice(i,1); score+=100; HUD.score.textContent=score; } break; } }
  // 体当たり
  if(circleHit(e.x,e.y,e.r, player.x,player.y,player.r)){ enemies.splice(i,1); damage(); }
}

// 敵弾（今回は簡易：たまに前方へ）
if(Math.random()<0.03){ enemyBullets.push({x:vw+10,y:40+Math.random()*(vh-80),vx:-260,vy:(Math.random()-0.5)*60,r:4}); }
for(let i=enemyBullets.length-1;i>=0;i--){ const eb=enemyBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>vw+40||eb.y<-40||eb.y>vh+40){ enemyBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ enemyBullets.splice(i,1); damage(); } }

if(state===STATE.gameover){ gameOverTimer+=dt; if(gameOverTimer>1.2){ setState(STATE.title); startOverlay.style.display='grid'; } }

}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); gameOverTimer=0; } }

// ===== 描画 ===== function draw(){ // 背景（星） cx.fillStyle='#061123'; cx.fillRect(0,0,vw,vh); cx.globalAlpha=.35; for(let x=0;x<vw;x+=24){ for(let y=0;y<vh;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1; // 自機 drawShip(player.x,player.y,player.r,'#7dd3fc'); // 弾 bullets.forEach(b=>drawBullet(b)); // 敵 enemies.forEach(e=>drawEnemy(e)); // 敵弾 enemyBullets.forEach(b=>drawEBullet(b));

if(state===STATE.title) banner('タップで開始','左：スティック 右：ショット');
if(state===STATE.paused) banner('PAUSED','もう一度タップで再開');
if(state===STATE.gameover) banner('GAME OVER','スコア: '+score);
if(state===STATE.win) banner('YOU WIN','スコア: '+score);

}

// ===== 開始 ===== startBtn.addEventListener('click', ()=>{ startOverlay.style.display='none'; reset(); setState(STATE.playing); }, {passive:true});

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh*0.3); cx.textAlign='center'; cx.font='700 40px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html> cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh*0.3); cx.textAlign='center'; cx.font='700 40px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html>s){
  finalBoss.x+=finalBoss.vx*dt; if(finalBoss.x<vw*0.65) finalBoss.vx=0; finalBoss.cd-=dt;
  if(finalBoss.cd<=0){ finalBoss.cd=0.16; const a=Math.random()*Math.PI*2; bossBullets.push({x:finalBoss.x,y:finalBoss.y,vx:Math.cos(a)*220,vy:Math.sin(a)*220,r:5}); }
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(finalBoss && circleHit(finalBoss.x,finalBoss.y,finalBoss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); finalBoss.hp-=10; if(finalBoss.hp<=0){ score+=5000; HUD.score.textContent=score; finalBoss=null; setState(STATE.win); break; } } }
}

// 敵弾／レーザー
for(let i=bossBullets.length-1;i>=0;i--){ const eb=bossBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>vw+40||eb.y<-40||eb.y>vh+40){ bossBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ bossBullets.splice(i,1); damage(); } }
for(let i=lasers.length-1;i>=0;i--){ const l=lasers[i]; l.time-=dt; if(l.time<=0){ lasers.splice(i,1); continue; } if(rectHit(l, player)){ lasers.splice(i,1); damage(); } }

}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); } }

// ===== 描画 ===== function draw(){ cx.fillStyle='#061123'; cx.fillRect(0,0,vw,vh); cx.globalAlpha=.35; for(let x=0;x<vw;x+=24){ for(let y=0;y<vh;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1; drawShip(player.x,player.y,player.r,'#7dd3fc'); bullets.forEach(b=>drawBullet(b)); enemies.forEach(e=>drawEnemy(e)); if(boss) drawBoss(boss,'#fde047'); if(finalBoss) drawBoss(finalBoss,'#f87171'); bossBullets.forEach(b=>drawEBullet(b)); lasers.forEach(l=>drawLaser(l)); if(state===STATE.title) banner('SF SHOOTER','▶ 開始 / 左：スティック 右：ショット'); if(state===STATE.paused) banner('PAUSED','もう一度ポーズで再開'); if(state===STATE.gameover) banner('GAME OVER','スコア: '+score); if(state===STATE.win) banner('YOU WIN','スコア: '+score); }

// ===== UIボタン ===== HUD.start.onclick=()=>{ if(state!==STATE.playing){ reset(); setState(STATE.playing); } }; HUD.pause.onclick=()=> setState(state===STATE.playing?STATE.paused:STATE.playing); HUD.reset.onclick=()=>{ reset(); setState(STATE.title); };

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function drawBoss(b,color){ cx.fillStyle=color; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); cx.fillStyle='#fff'; cx.fillText('HP:'+Math.max(0,Math.floor(b.hp||0)), b.x-24, b.y-b.r-10); } function drawLaser(l){ cx.fillStyle='rgba(255,0,0,0.45)'; cx.fillRect(l.x,l.y,l.w,l.h); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh0.3); cx.textAlign='center'; cx.font='700 48px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; } function rectHit(l,p){ return p.x>l.x && p.x<l.x+l.w && p.y>l.y && p.y<l.y+l.h; }

// ===== 簡易テスト ===== try{ console.assert(circleHit(0,0,10,9,0,1)===true,'circleHit TRUE'); console.assert(circleHit(0,0,10,25,0,1)===false,'circleHit FALSE'); }catch(e){ console.warn('tests failed', e); }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html>    background: rgba(255,0,0,0.8);
  }
  #left, #right {
    background: rgba(0,0,255,0.7);
  }
  #up, #down {
    background: rgba(0,255,0,0.7);
  }
</style>

<canvas id="gameCanvas"></canvas>

<div id="controls">
  <button id="left">←</button>
  <button id="right">→</button>
  <button id="up">↑</button>
  <button id="down">↓</button>
  <button id="fire">FIRE</button>
</div>er.y));

// ショット
player.cd-=dt; if((autoFire || wantShoot) && player.cd<=0){ bullets.push({x:player.x+player.r+2,y:player.y,vx:580,vy:0,r:5,life:1.3}); player.cd=autoFire?0.12:0.18; wantShoot=false; }
for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0 || b.x>vw+12) bullets.splice(i,1); }

// 雑魚
if(!boss && !finalBoss){
  enemyTimer-=dt; if(enemyTimer<=0){ enemyTimer=0.55; enemies.push({x:vw+20,y:40+Math.random()*(vh-80),r:14,vx:-220}); }
  for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.x+=e.vx*dt; if(e.x<-30){ enemies.splice(i,1); continue; }
    for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(circleHit(e.x,e.y,e.r, b.x,b.y,b.r)){ enemies.splice(i,1); bullets.splice(bi,1); score+=100; HUD.score.textContent=score; break; } }
    if(circleHit(e.x,e.y,e.r, player.x,player.y,player.r)){ enemies.splice(i,1); damage(); }
  }
  if(!midBossSpawned && score>=3000){ boss={x:vw+100,y:vh/2,r:44,hp:100,phase:1,vx:-70,cd:0}; midBossSpawned=true; }
}

// 中ボス
if(boss){
  boss.x+=boss.vx*dt; if(boss.x<vw*0.7) boss.vx=0; boss.cd-=dt;
  if(boss.phase===1){ if(boss.cd<=0){ boss.cd=0.42; bossBullets.push({x:boss.x,y:boss.y,vx:-220,vy:(Math.random()-0.5)*140,r:6}); } }
  else if(boss.phase===2){ if(boss.cd<=0){ boss.cd=0.1; const a=Math.random()*Math.PI*2; bossBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a)*200,vy:Math.sin(a)*200,r:4}); } if(Math.random()<0.02) lasers.push({x:boss.x-60,y:boss.y-110,w:220,h:220,time:0.5}); }
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(boss && circleHit(boss.x,boss.y,boss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); boss.hp-=1; if(boss.hp===50) boss.phase=2; if(boss.hp<=0){ score+=2000; HUD.score.textContent=score; boss=null; finalBossTimer=20; return; } } }
  if(boss && circleHit(boss.x,boss.y,boss.r, player.x,player.y,player.r)) damage();
}

// 最終ボス
if(finalBossTimer!==null){ finalBossTimer-=dt; if(finalBossTimer<=0){ finalBossTimer=null; finalBoss={x:vw+120,y:vh/2,r:52,hp:200,vx:-50,cd:0}; } }
if(finalBoss){
  finalBoss.x+=finalBoss.vx*dt; if(finalBoss.x<vw*0.65) finalBoss.vx=0; finalBoss.cd-=dt;
  if(finalBoss.cd<=0){ finalBoss.cd=0.16; const a=Math.random()*Math.PI*2; bossBullets.push({x:finalBoss.x,y:finalBoss.y,vx:Math.cos(a)*220,vy:Math.sin(a)*220,r:5}); }
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(finalBoss && circleHit(finalBoss.x,finalBoss.y,finalBoss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); finalBoss.hp-=10; if(finalBoss.hp<=0){ score+=5000; HUD.score.textContent=score; finalBoss=null; setState(STATE.win); break; } } }
}

// 敵弾／レーザー
for(let i=bossBullets.length-1;i>=0;i--){ const eb=bossBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>vw+40||eb.y<-40||eb.y>vh+40){ bossBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ bossBullets.splice(i,1); damage(); } }
for(let i=lasers.length-1;i>=0;i--){ const l=lasers[i]; l.time-=dt; if(l.time<=0){ lasers.splice(i,1); continue; } if(rectHit(l, player)){ lasers.splice(i,1); damage(); } }

}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); } }

// ===== 描画 ===== function draw(){ cx.fillStyle='#061123'; cx.fillRect(0,0,vw,vh); cx.globalAlpha=.35; for(let x=0;x<vw;x+=24){ for(let y=0;y<vh;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1; drawShip(player.x,player.y,player.r,'#7dd3fc'); bullets.forEach(b=>drawBullet(b)); enemies.forEach(e=>drawEnemy(e)); if(boss) drawBoss(boss,'#fde047'); if(finalBoss) drawBoss(finalBoss,'#f87171'); bossBullets.forEach(b=>drawEBullet(b)); lasers.forEach(l=>drawLaser(l)); if(state===STATE.title) banner('SF SHOOTER','▶ 開始 / 左：スティック 右：ショット'); if(state===STATE.paused) banner('PAUSED','もう一度ポーズで再開'); if(state===STATE.gameover) banner('GAME OVER','スコア: '+score); if(state===STATE.win) banner('YOU WIN','スコア: '+score); }

// ===== UIボタン ===== HUD.start.onclick=()=>{ if(state!==STATE.playing){ reset(); setState(STATE.playing); } }; HUD.pause.onclick=()=> setState(state===STATE.playing?STATE.paused:STATE.playing); HUD.reset.onclick=()=>{ reset(); setState(STATE.title); };

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function drawBoss(b,color){ cx.fillStyle=color; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); cx.fillStyle='#fff'; cx.fillText('HP:'+Math.max(0,Math.floor(b.hp||0)), b.x-24, b.y-b.r-10); } function drawLaser(l){ cx.fillStyle='rgba(255,0,0,0.45)'; cx.fillRect(l.x,l.y,l.w,l.h); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh0.3); cx.textAlign='center'; cx.font='700 48px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; } function rectHit(l,p){ return p.x>l.x && p.x<l.x+l.w && p.y>l.y && p.y<l.y+l.h; }

// ===== 簡易テスト ===== try{ console.assert(circleHit(0,0,10,9,0,1)===true,'circleHit TRUE'); console.assert(circleHit(0,0,10,25,0,1)===false,'circleHit FALSE'); }catch(e){ console.warn('tests failed', e); }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html><div id="controls">
  <div id="stick"><div id="stickKnob"></div></div>
  <div id="fire">FIRE</div>
</div>
<script>
'use strict';
(function(){
  // ===== 画面・DPR対応 =====
  const cv=document.getElementById('cv');
  const cx=cv.getContext('2d',{alpha:false});
  const HUD={ state:gid('state'), score:gid('score'), lives:gid('lives'), start:gid('btnStart'), pause:gid('btnPause'), reset:gid('btnReset') };
  const errBox=gid('err');
  const stick=document.getElementById('stick');
  const knob=document.getElementById('stickKnob');
  const fireBtn=document.getElementById('fire');
  function showErr(msg){ errBox.style.display='block'; errBox.textContent=String(msg); }
  if(!cx){ showErr('Canvas初期化に失敗'); }let vw=0,vh=0,dpr=1; function resize(){ dpr=Math.max(1, Math.min(3, window.devicePixelRatio||1)); vw=window.innerWidth; vh=window.innerHeight; cv.width=Math.floor(vwdpr); cv.height=Math.floor(vhdpr); cx.setTransform(dpr,0,0,dpr,0,0); } addEventListener('resize', resize); addEventListener('orientationchange', resize); resize();

// ===== 状態 ===== const STATE={title:'title',playing:'playing',paused:'paused',gameover:'gameover',win:'win'}; let state=STATE.title; const setState=s=>{state=s; HUD.state.textContent=s}; let score=0,lives=3;

// ===== ゲームオブジェクト ===== const player={x:vw0.18,y:vh0.5,r:14,speed:360,cd:0}; const bullets=[], enemies=[], bossBullets=[], lasers=[]; let enemyTimer=0, boss=null, finalBoss=null, finalBossTimer=null, midBossSpawned=false;

function reset(){ player.x=vw0.18; player.y=vh0.5; player.cd=0; bullets.length=enemies.length=bossBullets.length=lasers.length=0; enemyTimer=0; boss=null; finalBoss=null; finalBossTimer=null; midBossSpawned=false; score=0; lives=3; HUD.score.textContent=score; HUD.lives.textContent=lives; }

// ===== 入力（スティック＋ボタン＋キーボード） ===== let wantShoot=false, autoFire=false; const keys=new Set(); addEventListener('keydown',e=>{const k=(e.key||'').toLowerCase(); if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d',' '].includes(k)) e.preventDefault(); keys.add(k); if(k===' ') wantShoot=true;},{passive:false}); addEventListener('keyup',e=>{keys.delete((e.key||'').toLowerCase());},{passive:false});

// バーチャルスティック let joyActive=false, joyDX=0, joyDY=0, joyMax=1; // 正規化ベクトル function stickCenter(){ const r=stick.getBoundingClientRect(); return {cx:r.left+r.width/2, cy:r.top+r.height/2, rad:Math.min(r.width,r.height)/2}; } function updateKnob(px,py){ const {cx,cy,rad}=stickCenter(); const dx=px-cx, dy=py-cy; const dist=Math.hypot(dx,dy); const lim=rad0.9; const k = dist>lim ? lim/dist : 1; const nx=dxk, ny=dy*k; knob.style.transform=translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px)); joyDX = (dx===0&&dy===0)?0:(dx/lim); joyDY = (dx===0&&dy===0)?0:(dy/lim); const len=Math.min(1, Math.hypot(joyDX,joyDY)); if(len>0){ joyDX/=len; joyDY/=len; } } stick.addEventListener('pointerdown', ev=>{ joyActive=true; stick.setPointerCapture(ev.pointerId); updateKnob(ev.clientX,ev.clientY); ev.preventDefault(); },{passive:false}); stick.addEventListener('pointermove', ev=>{ if(!joyActive) return; updateKnob(ev.clientX,ev.clientY); }); function endStick(){ joyActive=false; joyDX=joyDY=0; knob.style.transform='translate(-50%,-50%)'; } stick.addEventListener('pointerup', endStick); stick.addEventListener('pointercancel', endStick); stick.addEventListener('pointerleave', endStick);

// 発射ボタン fireBtn.addEventListener('pointerdown', ev=>{ fireBtn.classList.add('pressed'); wantShoot=true; autoFire=true; ev.preventDefault(); },{passive:false}); function endFire(){ fireBtn.classList.remove('pressed'); autoFire=false; } fireBtn.addEventListener('pointerup', endFire); fireBtn.addEventListener('pointercancel', endFire); fireBtn.addEventListener('pointerleave', endFire);

// タブ非表示で一時停止 document.addEventListener('visibilitychange',()=>{ if(document.hidden && state===STATE.playing) setState(STATE.paused); });

// ===== ループ ===== let last=performance.now(); function loop(now){ const dt=Math.min(0.033, Math.max(0.001,(now-last)/1000)); last=now; if(state===STATE.playing) update(dt); draw(); requestAnimationFrame(loop); } requestAnimationFrame(loop);

// ===== 更新 ===== function update(dt){ // 移動（スティック優先 → キー） const dead=0.2; let up=false,down=false,left=false,right=false; if(joyActive){ up = (joyDY < -dead); down = (joyDY > dead); left = (joyDX < -dead); right = (joyDX > dead); } // キーの入力も合成 up = up || keys.has('arrowup') || keys.has('w'); down = down || keys.has('arrowdown') || keys.has('s'); left = left || keys.has('arrowleft') || keys.has('a'); right = right || keys.has('arrowright') || keys.has('d');

// 速度はスティックの強さでスケール
let speedScale = joyActive ? Math.min(1, Math.hypot(joyDX,joyDY)) : 1;
const v = player.speed * speedScale * dt;
if(up) player.y -= v; if(down) player.y += v; if(left) player.x -= v; if(right) player.x += v;
player.x=Math.max(player.r,Math.min(vw*0.8,player.x));
player.y=Math.max(player.r,Math.min(vh-player.r,player.y));

// ショット
player.cd-=dt; if((autoFire || wantShoot) && player.cd<=0){ bullets.push({x:player.x+player.r+2,y:player.y,vx:580,vy:0,r:5,life:1.3}); player.cd=autoFire?0.12:0.18; wantShoot=false; }
for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0 || b.x>vw+12) bullets.splice(i,1); }

// 雑魚
if(!boss && !finalBoss){
  enemyTimer-=dt; if(enemyTimer<=0){ enemyTimer=0.55; enemies.push({x:vw+20,y:40+Math.random()*(vh-80),r:14,vx:-220}); }
  for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.x+=e.vx*dt; if(e.x<-30){ enemies.splice(i,1); continue; }
    for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(circleHit(e.x,e.y,e.r, b.x,b.y,b.r)){ enemies.splice(i,1); bullets.splice(bi,1); score+=100; HUD.score.textContent=score; break; } }
    if(circleHit(e.x,e.y,e.r, player.x,player.y,player.r)){ enemies.splice(i,1); damage(); }
  }
  if(!midBossSpawned && score>=3000){ boss={x:vw+100,y:vh/2,r:44,hp:100,phase:1,vx:-70,cd:0}; midBossSpawned=true; }
}

// 中ボス
if(boss){
  boss.x+=boss.vx*dt; if(boss.x<vw*0.7) boss.vx=0; boss.cd-=dt;
  if(boss.phase===1){ if(boss.cd<=0){ boss.cd=0.42; bossBullets.push({x:boss.x,y:boss.y,vx:-220,vy:(Math.random()-0.5)*140,r:6}); } }
  else if(boss.phase===2){ if(boss.cd<=0){ boss.cd=0.1; const a=Math.random()*Math.PI*2; bossBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a)*200,vy:Math.sin(a)*200,r:4}); } if(Math.random()<0.02) lasers.push({x:boss.x-60,y:boss.y-110,w:220,h:220,time:0.5}); }
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(boss && circleHit(boss.x,boss.y,boss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); boss.hp-=1; if(boss.hp===50) boss.phase=2; if(boss.hp<=0){ score+=2000; HUD.score.textContent=score; boss=null; finalBossTimer=20; return; } } }
  if(boss && circleHit(boss.x,boss.y,boss.r, player.x,player.y,player.r)) damage();
}

// 最終ボス
if(finalBossTimer!==null){ finalBossTimer-=dt; if(finalBossTimer<=0){ finalBossTimer=null; finalBoss={x:vw+120,y:vh/2,r:52,hp:200,vx:-50,cd:0}; } }
if(finalBoss){
  finalBoss.x+=finalBoss.vx*dt; if(finalBoss.x<vw*0.65) finalBoss.vx=0; finalBoss.cd-=dt;
  if(finalBoss.cd<=0){ finalBoss.cd=0.16; const a=Math.random()*Math.PI*2; bossBullets.push({x:finalBoss.x,y:finalBoss.y,vx:Math.cos(a)*220,vy:Math.sin(a)*220,r:5}); }
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(finalBoss && circleHit(finalBoss.x,finalBoss.y,finalBoss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); finalBoss.hp-=10; if(finalBoss.hp<=0){ score+=5000; HUD.score.textContent=score; finalBoss=null; setState(STATE.win); break; } } }
}

// 敵弾／レーザー
for(let i=bossBullets.length-1;i>=0;i--){ const eb=bossBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>vw+40||eb.y<-40||eb.y>vh+40){ bossBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ bossBullets.splice(i,1); damage(); } }
for(let i=lasers.length-1;i>=0;i--){ const l=lasers[i]; l.time-=dt; if(l.time<=0){ lasers.splice(i,1); continue; } if(rectHit(l, player)){ lasers.splice(i,1); damage(); } }

}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); } }

// ===== 描画 ===== function draw(){ cx.fillStyle='#061123'; cx.fillRect(0,0,vw,vh); cx.globalAlpha=.35; for(let x=0;x<vw;x+=24){ for(let y=0;y<vh;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1; drawShip(player.x,player.y,player.r,'#7dd3fc'); bullets.forEach(b=>drawBullet(b)); enemies.forEach(e=>drawEnemy(e)); if(boss) drawBoss(boss,'#fde047'); if(finalBoss) drawBoss(finalBoss,'#f87171'); bossBullets.forEach(b=>drawEBullet(b)); lasers.forEach(l=>drawLaser(l)); if(state===STATE.title) banner('SF SHOOTER','▶ 開始 / 左：スティック 右：ショット'); if(state===STATE.paused) banner('PAUSED','もう一度ポーズで再開'); if(state===STATE.gameover) banner('GAME OVER','スコア: '+score); if(state===STATE.win) banner('YOU WIN','スコア: '+score); }

// ===== UIボタン ===== HUD.start.onclick=()=>{ if(state!==STATE.playing){ reset(); setState(STATE.playing); } }; HUD.pause.onclick=()=> setState(state===STATE.playing?STATE.paused:STATE.playing); HUD.reset.onclick=()=>{ reset(); setState(STATE.title); };

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function drawBoss(b,color){ cx.fillStyle=color; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); cx.fillStyle='#fff'; cx.fillText('HP:'+Math.max(0,Math.floor(b.hp||0)), b.x-24, b.y-b.r-10); } function drawLaser(l){ cx.fillStyle='rgba(255,0,0,0.45)'; cx.fillRect(l.x,l.y,l.w,l.h); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh0.3); cx.textAlign='center'; cx.font='700 48px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; } function rectHit(l,p){ return p.x>l.x && p.x<l.x+l.w && p.y>l.y && p.y<l.y+l.h; }

// ===== 簡易テスト ===== try{ console.assert(circleHit(0,0,10,9,0,1)===true,'circleHit TRUE'); console.assert(circleHit(0,0,10,25,0,1)===false,'circleHit FALSE'); }catch(e){ console.warn('tests failed', e); }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html><div id="controls">
  <div id="stick"><div id="stickKnob"></div></div>
  <div id="fire">FIRE</div>
</div>
<script>
'use strict';
(function(){
  // ===== 画面・DPR対応 =====
  const cv=document.getElementById('cv');
  const cx=cv.getContext('2d',{alpha:false});
  const HUD={ state:gid('state'), score:gid('score'), lives:gid('lives'), start:gid('btnStart'), pause:gid('btnPause'), reset:gid('btnReset') };
  const errBox=gid('err');
  const stick=document.getElementById('stick');
  const knob=document.getElementById('stickKnob');
  const fireBtn=document.getElementById('fire');
  function showErr(msg){ errBox.style.display='block'; errBox.textContent=String(msg); }
  if(!cx){ showErr('Canvas初期化に失敗'); }let vw=0,vh=0,dpr=1; function resize(){ dpr=Math.max(1, Math.min(3, window.devicePixelRatio||1)); vw=window.innerWidth; vh=window.innerHeight; cv.width=Math.floor(vwdpr); cv.height=Math.floor(vhdpr); cx.setTransform(dpr,0,0,dpr,0,0); } addEventListener('resize', resize); addEventListener('orientationchange', resize); resize();

// ===== 状態 ===== const STATE={title:'title',playing:'playing',paused:'paused',gameover:'gameover',win:'win'}; let state=STATE.title; const setState=s=>{state=s; HUD.state.textContent=s}; let score=0,lives=3;

// ===== ゲームオブジェクト ===== const player={x:vw0.18,y:vh0.5,r:14,speed:360,cd:0}; const bullets=[], enemies=[], bossBullets=[], lasers=[]; let enemyTimer=0, boss=null, finalBoss=null, finalBossTimer=null, midBossSpawned=false;

function reset(){ player.x=vw0.18; player.y=vh0.5; player.cd=0; bullets.length=enemies.length=bossBullets.length=lasers.length=0; enemyTimer=0; boss=null; finalBoss=null; finalBossTimer=null; midBossSpawned=false; score=0; lives=3; HUD.score.textContent=score; HUD.lives.textContent=lives; }

// ===== 入力（スティック＋ボタン＋キーボード） ===== let wantShoot=false, autoFire=false; const keys=new Set(); addEventListener('keydown',e=>{const k=(e.key||'').toLowerCase(); if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d',' '].includes(k)) e.preventDefault(); keys.add(k); if(k===' ') wantShoot=true;},{passive:false}); addEventListener('keyup',e=>{keys.delete((e.key||'').toLowerCase());},{passive:false});

// バーチャルスティック let joyActive=false, joyDX=0, joyDY=0, joyMax=1; // 正規化ベクトル function stickCenter(){ const r=stick.getBoundingClientRect(); return {cx:r.left+r.width/2, cy:r.top+r.height/2, rad:Math.min(r.width,r.height)/2}; } function updateKnob(px,py){ const {cx,cy,rad}=stickCenter(); const dx=px-cx, dy=py-cy; const dist=Math.hypot(dx,dy); const lim=rad0.9; const k = dist>lim ? lim/dist : 1; const nx=dxk, ny=dy*k; knob.style.transform=translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px)); joyDX = (dx===0&&dy===0)?0:(dx/lim); joyDY = (dx===0&&dy===0)?0:(dy/lim); const len=Math.min(1, Math.hypot(joyDX,joyDY)); if(len>0){ joyDX/=len; joyDY/=len; } } stick.addEventListener('pointerdown', ev=>{ joyActive=true; stick.setPointerCapture(ev.pointerId); updateKnob(ev.clientX,ev.clientY); ev.preventDefault(); },{passive:false}); stick.addEventListener('pointermove', ev=>{ if(!joyActive) return; updateKnob(ev.clientX,ev.clientY); }); function endStick(){ joyActive=false; joyDX=joyDY=0; knob.style.transform='translate(-50%,-50%)'; } stick.addEventListener('pointerup', endStick); stick.addEventListener('pointercancel', endStick); stick.addEventListener('pointerleave', endStick);

// 発射ボタン fireBtn.addEventListener('pointerdown', ev=>{ fireBtn.classList.add('pressed'); wantShoot=true; autoFire=true; ev.preventDefault(); },{passive:false}); function endFire(){ fireBtn.classList.remove('pressed'); autoFire=false; } fireBtn.addEventListener('pointerup', endFire); fireBtn.addEventListener('pointercancel', endFire); fireBtn.addEventListener('pointerleave', endFire);

// タブ非表示で一時停止 document.addEventListener('visibilitychange',()=>{ if(document.hidden && state===STATE.playing) setState(STATE.paused); });

// ===== ループ ===== let last=performance.now(); function loop(now){ const dt=Math.min(0.033, Math.max(0.001,(now-last)/1000)); last=now; if(state===STATE.playing) update(dt); draw(); requestAnimationFrame(loop); } requestAnimationFrame(loop);

// ===== 更新 ===== function update(dt){ // 移動（スティック優先 → キー） const dead=0.2; let up=false,down=false,left=false,right=false; if(joyActive){ up = (joyDY < -dead); down = (joyDY > dead); left = (joyDX < -dead); right = (joyDX > dead); } // キーの入力も合成 up = up || keys.has('arrowup') || keys.has('w'); down = down || keys.has('arrowdown') || keys.has('s'); left = left || keys.has('arrowleft') || keys.has('a'); right = right || keys.has('arrowright') || keys.has('d');

// 速度はスティックの強さでスケール
let speedScale = joyActive ? Math.min(1, Math.hypot(joyDX,joyDY)) : 1;
const v = player.speed * speedScale * dt;
if(up) player.y -= v; if(down) player.y += v; if(left) player.x -= v; if(right) player.x += v;
player.x=Math.max(player.r,Math.min(vw*0.8,player.x));
player.y=Math.max(player.r,Math.min(vh-player.r,player.y));

// ショット
player.cd-=dt; if((autoFire || wantShoot) && player.cd<=0){ bullets.push({x:player.x+player.r+2,y:player.y,vx:580,vy:0,r:5,life:1.3}); player.cd=autoFire?0.12:0.18; wantShoot=false; }
for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0 || b.x>vw+12) bullets.splice(i,1); }

// 雑魚
if(!boss && !finalBoss){
  enemyTimer-=dt; if(enemyTimer<=0){ enemyTimer=0.55; enemies.push({x:vw+20,y:40+Math.random()*(vh-80),r:14,vx:-220}); }
  for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.x+=e.vx*dt; if(e.x<-30){ enemies.splice(i,1); continue; }
    for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(circleHit(e.x,e.y,e.r, b.x,b.y,b.r)){ enemies.splice(i,1); bullets.splice(bi,1); score+=100; HUD.score.textContent=score; break; } }
    if(circleHit(e.x,e.y,e.r, player.x,player.y,player.r)){ enemies.splice(i,1); damage(); }
  }
  if(!midBossSpawned && score>=3000){ boss={x:vw+100,y:vh/2,r:44,hp:100,phase:1,vx:-70,cd:0}; midBossSpawned=true; }
}

// 中ボス
if(boss){
  boss.x+=boss.vx*dt; if(boss.x<vw*0.7) boss.vx=0; boss.cd-=dt;
  if(boss.phase===1){ if(boss.cd<=0){ boss.cd=0.42; bossBullets.push({x:boss.x,y:boss.y,vx:-220,vy:(Math.random()-0.5)*140,r:6}); } }
  else if(boss.phase===2){ if(boss.cd<=0){ boss.cd=0.1; const a=Math.random()*Math.PI*2; bossBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a)*200,vy:Math.sin(a)*200,r:4}); } if(Math.random()<0.02) lasers.push({x:boss.x-60,y:boss.y-110,w:220,h:220,time:0.5}); }
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(boss && circleHit(boss.x,boss.y,boss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); boss.hp-=1; if(boss.hp===50) boss.phase=2; if(boss.hp<=0){ score+=2000; HUD.score.textContent=score; boss=null; finalBossTimer=20; return; } } }
  if(boss && circleHit(boss.x,boss.y,boss.r, player.x,player.y,player.r)) damage();
}

// 最終ボス
if(finalBossTimer!==null){ finalBossTimer-=dt; if(finalBossTimer<=0){ finalBossTimer=null; finalBoss={x:vw+120,y:vh/2,r:52,hp:200,vx:-50,cd:0}; } }
if(finalBoss){
  finalBoss.x+=finalBoss.vx*dt; if(finalBoss.x<vw*0.65) finalBoss.vx=0; finalBoss.cd-=dt;
  if(finalBoss.cd<=0){ finalBoss.cd=0.16; const a=Math.random()*Math.PI*2; bossBullets.push({x:finalBoss.x,y:finalBoss.y,vx:Math.cos(a)*220,vy:Math.sin(a)*220,r:5}); }
  for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(finalBoss && circleHit(finalBoss.x,finalBoss.y,finalBoss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); finalBoss.hp-=10; if(finalBoss.hp<=0){ score+=5000; HUD.score.textContent=score; finalBoss=null; setState(STATE.win); break; } } }
}

// 敵弾／レーザー
for(let i=bossBullets.length-1;i>=0;i--){ const eb=bossBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>vw+40||eb.y<-40||eb.y>vh+40){ bossBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ bossBullets.splice(i,1); damage(); } }
for(let i=lasers.length-1;i>=0;i--){ const l=lasers[i]; l.time-=dt; if(l.time<=0){ lasers.splice(i,1); continue; } if(rectHit(l, player)){ lasers.splice(i,1); damage(); } }

}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); } }

// ===== 描画 ===== function draw(){ cx.fillStyle='#061123'; cx.fillRect(0,0,vw,vh); cx.globalAlpha=.35; for(let x=0;x<vw;x+=24){ for(let y=0;y<vh;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1; drawShip(player.x,player.y,player.r,'#7dd3fc'); bullets.forEach(b=>drawBullet(b)); enemies.forEach(e=>drawEnemy(e)); if(boss) drawBoss(boss,'#fde047'); if(finalBoss) drawBoss(finalBoss,'#f87171'); bossBullets.forEach(b=>drawEBullet(b)); lasers.forEach(l=>drawLaser(l)); if(state===STATE.title) banner('SF SHOOTER','▶ 開始 / 左：スティック 右：ショット'); if(state===STATE.paused) banner('PAUSED','もう一度ポーズで再開'); if(state===STATE.gameover) banner('GAME OVER','スコア: '+score); if(state===STATE.win) banner('YOU WIN','スコア: '+score); }

// ===== UIボタン ===== HUD.start.onclick=()=>{ if(state!==STATE.playing){ reset(); setState(STATE.playing); } }; HUD.pause.onclick=()=> setState(state===STATE.playing?STATE.paused:STATE.playing); HUD.reset.onclick=()=>{ reset(); setState(STATE.title); };

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function drawBoss(b,color){ cx.fillStyle=color; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); cx.fillStyle='#fff'; cx.fillText('HP:'+Math.max(0,Math.floor(b.hp||0)), b.x-24, b.y-b.r-10); } function drawLaser(l){ cx.fillStyle='rgba(255,0,0,0.45)'; cx.fillRect(l.x,l.y,l.w,l.h); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh0.3); cx.textAlign='center'; cx.font='700 48px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; } function rectHit(l,p){ return p.x>l.x && p.x<l.x+l.w && p.y>l.y && p.y<l.y+l.h; }

// ===== 簡易テスト ===== try{ console.assert(circleHit(0,0,10,9,0,1)===true,'circleHit TRUE'); console.assert(circleHit(0,0,10,25,0,1)===false,'circleHit FALSE'); }catch(e){ console.warn('tests failed', e); }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html>ick=()=>{ reset(); setState(STATE.title); };

// ===== 描画ヘルパ ===== function drawShip(x,y,r,color){ cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r0.8,y-r0.9); cx.lineTo(x-r0.6,y+r0.9); cx.closePath(); cx.fill(); } function drawBullet(b){ cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); } function drawEnemy(e){ cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI2); cx.fill(); } function drawBoss(b,color){ cx.fillStyle=color; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI2); cx.fill(); cx.fillStyle='#fff'; cx.fillText('HP:'+Math.max(0,Math.floor(b.hp||0)), b.x-24, b.y-b.r-10); } function drawLaser(l){ cx.fillStyle='rgba(255,0,0,0.45)'; cx.fillRect(l.x,l.y,l.w,l.h); } function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, vh0.35, vw, vh0.3); cx.textAlign='center'; cx.font='700 48px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, vw/2, vh/2); cx.font='14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, vw/2, vh/2+28); }

// ===== 判定 ===== function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dxdx+dydy<=rr*rr; } function rectHit(l,p){ return p.x>l.x && p.x<l.x+l.w && p.y>l.y && p.y<l.y+l.h; }

// ===== 簡易テスト ===== try{ console.assert(circleHit(0,0,10,9,0,1)===true,'circleHit TRUE'); console.assert(circleHit(0,0,10,25,0,1)===false,'circleHit FALSE'); }catch(e){ console.warn('tests failed', e); }

function gid(id){ return document.getElementById(id); } })(); </script>

</body>
</html>
const HUD={ state:gid('state'), score:gid('score'), lives:gid('lives'), start:gid('btnStart'), pause:gid('btnPause'), reset:gid('btnReset') };
for(const [k,v] of Object.entries(HUD)) if(!v){ showErr('HUD要素が見つかりません: '+k); return; }

const STATE={title:'title',playing:'playing',paused:'paused',gameover:'gameover',win:'win'}; let state=STATE.title; const setState=s=>{state=s; HUD.state.textContent=s};

// 入力
const keys=new Set(); let wantShoot=false; let midBossSpawned=false;
addEventListener('keydown',e=>{const c=e.code, k=(e.key||'').toLowerCase(); const g=['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space','KeyW','KeyA','KeyS','KeyD','KeyP'].includes(c)||['arrowup','arrowdown','arrowleft','arrowright',' ','w','a','s','d','p'].includes(k); if(g) e.preventDefault(); keys.add((k||c).toLowerCase()); if(c==='Space'||k===' ') wantShoot=true; if(c==='KeyP'||k==='p') togglePause();},{passive:false});
addEventListener('keyup',e=>{const c=e.code, k=(e.key||'').toLowerCase(); keys.delete((k||c).toLowerCase());},{passive:false});

HUD.start.onclick=()=>{ if(state!==STATE.playing){ reset(); setState(STATE.playing); cv.focus(); } };
HUD.pause.onclick=()=> togglePause();
HUD.reset.onclick=()=>{ reset(); setState(STATE.title); };
function togglePause(){ setState(state===STATE.playing?STATE.paused:STATE.playing); }

// 世界
const player={x:cv.width*0.18,y:cv.height*0.5,r:14,speed:300,cd:0};
const bullets=[], enemies=[], bossBullets=[], lasers=[];
let enemyTimer=0, boss=null, finalBoss=null, finalBossTimer=null, score=0, lives=3;

function reset(){
  player.x=cv.width*0.18; player.y=cv.height*0.5; player.cd=0;
  bullets.length=0; enemies.length=0; bossBullets.length=0; lasers.length=0;
  enemyTimer=0; boss=null; finalBoss=null; finalBossTimer=null; midBossSpawned=false;
  score=0; lives=3; HUD.score.textContent=score; HUD.lives.textContent=lives;
}

// ループ
let last=performance.now();
function loop(now){ const dt=Math.min(0.033,Math.max(0.001,(now-last)/1000)); last=now; if(state===STATE.playing) update(dt); draw(); requestAnimationFrame(loop);} requestAnimationFrame(loop);

function update(dt){
  // 入力
  const up=keys.has('arrowup')||keys.has('keyw'); const down=keys.has('arrowdown')||keys.has('keys'); const left=keys.has('arrowleft')||keys.has('keya'); const right=keys.has('arrowright')||keys.has('keyd');
  if(up) player.y-=player.speed*dt; if(down) player.y+=player.speed*dt; if(left) player.x-=player.speed*dt; if(right) player.x+=player.speed*dt;
  player.x=Math.max(player.r,Math.min(cv.width*0.8,player.x)); player.y=Math.max(player.r,Math.min(cv.height-player.r,player.y));

  // 自機弾
  player.cd-=dt; if(wantShoot && player.cd<=0){ bullets.push({x:player.x+player.r+2,y:player.y,vx:580,vy:0,r:4,life:1.3}); player.cd=0.12; wantShoot=false; }
  for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if(b.life<=0||b.x>cv.width+12) bullets.splice(i,1); }

  // 雑魚（ボス不在時のみ）
  if(!boss && !finalBoss){
    enemyTimer-=dt; if(enemyTimer<=0){ enemyTimer=0.5; enemies.push({x:cv.width+20,y:40+Math.random()*(cv.height-80),r:12,vx:-200}); }
    for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; e.x+=e.vx*dt; if(e.x<-30){ enemies.splice(i,1); continue; }
      // 弾 vs 雑魚
      for(let bi=bullets.length-1;bi>=0;bi--){ const b=bullets[bi]; if(circleHit(e.x,e.y,e.r, b.x,b.y,b.r)){ enemies.splice(i,1); bullets.splice(bi,1); score+=100; HUD.score.textContent=score; break; } }
      // 雑魚 vs 自機
      if(circleHit(e.x,e.y,e.r, player.x,player.y,player.r)){ enemies.splice(i,1); damage(); }
    }
    // 中ボス出現（1回のみ）
    if(!midBossSpawned && score>=3000){ boss={x:cv.width+100,y:cv.height/2,r:40,hp:100,phase:1,vx:-60,cd:0}; midBossSpawned=true; }
  }

  // 中ボス
  if(boss){
    boss.x+=boss.vx*dt; if(boss.x<cv.width*0.7) boss.vx=0; boss.cd-=dt;
    if(boss.phase===1){ if(boss.cd<=0){ boss.cd=0.4; bossBullets.push({x:boss.x,y:boss.y,vx:-200,vy:(Math.random()-0.5)*120,r:6}); } }
    else if(boss.phase===2){ if(boss.cd<=0){ boss.cd=0.1; const a=Math.random()*Math.PI*2; bossBullets.push({x:boss.x,y:boss.y,vx:Math.cos(a)*180,vy:Math.sin(a)*180,r:4}); } if(Math.random()<0.02) lasers.push({x:boss.x-50,y:boss.y-100,w:200,h:200,time:0.5}); }

    // 自機弾 vs 中ボス（nullガード＋早期スキップ入り）
    for(let bi=bullets.length-1; bi>=0; bi--){ const b=bullets[bi]; if(boss && circleHit(boss.x,boss.y,boss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); boss.hp-=1; if(boss.hp===50) boss.phase=2; if(boss.hp<=0){ score+=2000; HUD.score.textContent=score; boss=null; finalBossTimer=20; return; } } }

    // 体当たり（bossが存在する時のみ）
    if(boss && circleHit(boss.x,boss.y,boss.r, player.x,player.y,player.r)) damage();
  }

  // 最終ボス出現タイマー
  if(finalBossTimer!==null){ finalBossTimer-=dt; if(finalBossTimer<=0){ finalBossTimer=null; finalBoss={x:cv.width+120,y:cv.height/2,r:50,hp:200,vx:-40,cd:0}; } }

  // 最終ボス
  if(finalBoss){
    finalBoss.x+=finalBoss.vx*dt; if(finalBoss.x<cv.width*0.65) finalBoss.vx=0; finalBoss.cd-=dt;
    if(finalBoss.cd<=0){ finalBoss.cd=0.15; const a=Math.random()*Math.PI*2; bossBullets.push({x:finalBoss.x,y:finalBoss.y,vx:Math.cos(a)*200,vy:Math.sin(a)*200,r:5}); }
    // 自機弾 vs 最終ボス（防御）
    for(let bi=bullets.length-1; bi>=0; bi--){ const b=bullets[bi]; if(finalBoss && circleHit(finalBoss.x,finalBoss.y,finalBoss.r, b.x,b.y,b.r)){ bullets.splice(bi,1); finalBoss.hp-=10; if(finalBoss.hp<=0){ score+=5000; HUD.score.textContent=score; finalBoss=null; setState(STATE.win); break; } } }
  }

  // 敵弾
  for(let i=bossBullets.length-1;i>=0;i--){ const eb=bossBullets[i]; eb.x+=eb.vx*dt; eb.y+=eb.vy*dt; if(eb.x<-40||eb.x>cv.width+40||eb.y<-40||eb.y>cv.height+40){ bossBullets.splice(i,1); continue; } if(circleHit(eb.x,eb.y,eb.r, player.x,player.y,player.r)){ bossBullets.splice(i,1); damage(); } }

  // レーザー
  for(let i=lasers.length-1;i>=0;i--){ const l=lasers[i]; l.time-=dt; if(l.time<=0){ lasers.splice(i,1); continue; } if(rectHit(l, player)){ lasers.splice(i,1); damage(); } }
}

function damage(){ lives--; HUD.lives.textContent=lives; if(lives<=0){ setState(STATE.gameover); } }

function draw(){
  cx.clearRect(0,0,cv.width,cv.height);
  // 背景
  cx.globalAlpha=.35; for(let x=0;x<cv.width;x+=24){ for(let y=0;y<cv.height;y+=18){ cx.fillStyle='#20314d'; cx.fillRect((x+((x*y)%7)), (y+((x+y)%5)), 2, 2); } } cx.globalAlpha=1;
  // 自機
  drawShip(player.x,player.y,player.r,'#7dd3fc');
  // 弾
  bullets.forEach(b=>drawBullet(b));
  // 雑魚
  enemies.forEach(e=>drawEnemy(e));
  // ボス
  if(boss) drawBoss(boss,'#fde047');
  if(finalBoss) drawBoss(finalBoss,'#f87171');
  // 敵弾
  bossBullets.forEach(b=>drawEBullet(b));
  // レーザー
  lasers.forEach(l=>drawLaser(l));

  if(state===STATE.title) banner('SF SHOOTER','▶ スタートで開始 / 矢印・WASD・Space');
  if(state===STATE.paused) banner('PAUSED','P で再開');
  if(state===STATE.gameover) banner('GAME OVER','スコア: '+score);
  if(state===STATE.win) banner('YOU WIN','スコア: '+score);
}

// 描画ヘルパ
function drawShip(x,y,r,color){ cx.shadowColor=color; cx.shadowBlur=18; cx.fillStyle=color; cx.beginPath(); cx.moveTo(x+r,y); cx.lineTo(x-r*0.8,y-r*0.9); cx.lineTo(x-r*0.6,y+r*0.9); cx.closePath(); cx.fill(); cx.shadowBlur=0; }
function drawBullet(b){ cx.shadowColor='#67e8f9'; cx.shadowBlur=12; cx.fillStyle='#e0f2fe'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI*2); cx.fill(); cx.shadowBlur=0; }
function drawEBullet(b){ cx.fillStyle='#fbbf24'; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI*2); cx.fill(); }
function drawEnemy(e){ cx.shadowColor='#a78bfa'; cx.shadowBlur=16; cx.fillStyle='#a78bfa'; cx.beginPath(); cx.arc(e.x,e.y,e.r,0,Math.PI*2); cx.fill(); cx.shadowBlur=0; }
function drawBoss(b,color){ cx.shadowColor=color; cx.shadowBlur=24; cx.fillStyle=color; cx.beginPath(); cx.arc(b.x,b.y,b.r,0,Math.PI*2); cx.fill(); cx.shadowBlur=0; cx.fillStyle='#fff'; cx.fillText('HP:'+Math.max(0,Math.floor(b.hp||0)), b.x-24, b.y-b.r-10); }
function drawLaser(l){ cx.fillStyle='rgba(255,0,0,0.45)'; cx.fillRect(l.x,l.y,l.w,l.h); }
function banner(t,s){ cx.fillStyle='rgba(0,0,0,0.45)'; cx.fillRect(0, cv.height*0.35, cv.width, cv.height*0.3); cx.textAlign='center'; cx.font='700 64px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, cv.width/2, cv.height/2); cx.font = '14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, cv.width/2, cv.height/2+28); }

// 判定
function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dx*dx+dy*dy<=rr*rr; }
function rectHit(l,p){ return p.x>l.x && p.x<l.x+l.w && p.y>l.y && p.y<l.y+l.h; }

// 簡易テスト
try{
  console.assert(circleHit(0,0,10, 9,0,1)===true, 'circleHit TRUE');
  console.assert(circleHit(0,0,10, 25,0,1)===false, 'circleHit FALSE');
  console.assert(rectHit({x:0,y:0,w:10,h:10},{x:5,y:5})===true, 'rectHit TRUE');
  console.assert(rectHit({x:0,y:0,w:10,h:10},{x:20,y:20})===false, 'rectHit FALSE');
}catch(e){ console.warn('self tests failed', e); }

function gid(id){ return document.getElementById(id); }

} })(); </script>

</body>
</html>0,0,0.45)'; cx.fillRect(0, cv.height*0.35, cv.width, cv.height*0.3); cx.textAlign='center'; cx.font='700 64px system-ui'; cx.fillStyle='#e2e8f0'; cx.fillText(t, cv.width/2, cv.height/2); cx.font = '14px system-ui'; cx.fillStyle='#a3b2c7'; cx.fillText(s, cv.width/2, cv.height/2+28); }

// 判定
function circleHit(x1,y1,r1,x2,y2,r2){ const dx=x1-x2, dy=y1-y2; const rr=r1+r2; return dx*dx+dy*dy<=rr*rr; }
function rectHit(l,p){ return p.x>l.x && p.x<l.x+l.w && p.y>l.y && p.y<l.y+l.h; }

// 簡易テスト
try{
  console.assert(circleHit(0,0,10, 9,0,1)===true, 'circleHit TRUE');
  console.assert(circleHit(0,0,10, 25,0,1)===false, 'circleHit FALSE');
  console.assert(rectHit({x:0,y:0,w:10,h:10},{x:5,y:5})===true, 'rectHit TRUE');
  console.assert(rectHit({x:0,y:0,w:10,h:10},{x:20,y:20})===false, 'rectHit FALSE');
}catch(e){ console.warn('self tests failed', e); }

function gid(id){ return document.getElementById(id); }

} })(); </script>

</body>
</html>
